\documentclass[a4paper,openany,oneside,12pt]{book}
\usepackage[left=3cm, right=2.5cm, top=2.5cm, bottom=2.5cm]{geometry}
\usepackage{setspace}
\onehalfspacing
\usepackage[spanish]{babel}
\usepackage{mathpazo}
\usepackage{graphicx}
\usepackage[utf8]{inputenc} % Para poner acentos y eñes directamente.
\usepackage{pdfpages}
\usepackage{listings}
\usepackage[T1]{fontenc}
\usepackage{hyperref}
\usepackage{algorithm2e}
\usepackage{float} 


\usepackage{fancyhdr}
\pagestyle{fancy}
\fancyhf{}  % Limpia encabezado y pie

% Redefinir la marca de capítulo: se guarda el título del capítulo en \leftmark y además se asigna a \rightmark.
\renewcommand{\chaptermark}[1]{%
  \markboth{\thechapter.\ #1}{}%
  \markright{\thechapter.\ #1}%
}


\fancyhead[L]{\nouppercase{\textit{\leftmark}}}
\fancyhead[R]{\thepage}




\usepackage{titlesec}
\titleformat{\chapter}[display]
  {\normalfont\fontfamily{phv}\selectfont\Huge\bfseries}{}
  {0pt}{\Huge}
\titleformat{\section}
  {\normalfont\fontfamily{phv}\selectfont\Large\bfseries}{\thesection}{1em}{}

\usepackage{courier} % Esto configura \ttfamily a Courier
\lstset{basicstyle=\fontfamily{pcr}\selectfont}

\SetAlFnt{\fontfamily{pcr}\selectfont\footnotesize}




\renewcommand{\textsharp}{$\sharp$}

\begin{document}

\includepdf[pages={1}]{img/Portada_GII.pdf}
\newpage
\mbox{}

\thispagestyle{empty} % para que no se numere esta pagina

\title{Asistente de composici\'on de m\'usica dodecaf\'onica para OpenMusic}
\author{
        Leopoldo Pla Sempere (lps34 at alu dot ua dot es)\\
        Universidad de Alicante\\
}

\date{\today}
\maketitle

\newpage
\mbox{}
\thispagestyle{empty} % para que no se numere esta pagina



\chapter*{Agradecimientos}
\pagenumbering{arabic}
\setcounter{page}{1}
\addcontentsline{toc}{chapter}{Agradecimientos} % si queremos que aparezca en el índice
\markboth{AGRADECIMIENTOS}{AGRADECIMIENTOS} % encabezado

\addcontentsline{toc}{chapter}{Agradecimientos} % si queremos que aparezca en el índice
\markboth{AGRADECIMIENTOS}{AGRADECIMIENTOS} % encabezado
 
Agradecer este trabajo a mi familia por la ayuda y el apoyo que me han dado para llegar a crear este documento que mezcla dos mundos muchas veces duros de conllevar.

A mi tutor, Carlos, por orientar de una manera sencilla el proyecto y ser honesto con los objetivos propuestos.

A mis compañeros y profesores del grado, con los que he compartido muy buenos momentos y mucha experiencia profesional.

\chapter*{Licencia}
Documento liberado bajo licencia Creative Commons Attribution - ShareAlike 4.0 International (CC BY-SA).

\url{http://creativecommons.org/licenses/by-sa/4.0/}



Código fuente bajo licencia GNU GENERAL PUBLIC LICENSE (GPL).

\url{http://www.gnu.org/copyleft/gpl.html}



\begin{figure}
\centering
\includegraphics{img/cc.png} 

This work is licensed under a Creative Commons Attribution-ShareAlike 4.0 International License.
\end{figure}

\chapter*{}
\begin{flushright}
\textit{Dedicado a \\
Laura}
\end{flushright}


\chapter*{Resumen}
\addcontentsline{toc}{section}{Resumen} % si queremos que aparezca en el índice
\markboth{RESUMEN}{RESUMEN} % encabezado

Este trabajo se ha realizado para unir los conocimientos del Grado Profesional de música y el Grado en Ingeniería Informática en un proyecto de composición automática que asista a los compositores a componer obras dodecafónicas, obras interesantes desde el punto de vista matemático y programático.

El dodecafonismo es un método de composición musical basado en una serie de doce notas (las de la escala cromática) donde no existe centro tonal. Esa serie se deriva en una matriz de series que es la utilizada para componer las obras dodecafónicas.

La composición automática es una forma de composición basada en elementos mecánicos, o más frecuentemente electrónicos y digitales, en la toma de decisiones.

Así pues, el asistente de composición de música dodecafónica es un conjunto de capas software implementadas sobre varias tecnologías, entre ellas OpenMusic y Python, para crear obras dodecafónicas según unas restricciones impuestas por el usuario. El sistema es capaz de obtener una serie dodecafónica en base a una semilla propuesta cumpliendo además ciertas restricciones para luego obtener todas las series derivadas de ella y componer con estas series y otras restricciones.

Se genera una partitura con ritmos, saltos de octava y silencios además de poder exportar el resultado a formato MusicXML para poder seguir editando en cualquier editor de partituras actual. Aquí presentaremos y mostraremos en imágenes el asistente con algunos ejemplos así como de exponer diferentes partes de su desarrollo. También se mostrará la estructura y la programación del programa bajo las diferentes tecnologías utilizadas y se sugieren enfoques para el futuro desarrollo.

Solventados los problemas durante el desarrollo incremental de este proyecto, los resultados son satisfactorios y han surgido nuevas ideas para futuros desarrollos derivados, mejoras y expansiones de este proyecto.

\newpage


\tableofcontents % indice de contenidos

\cleardoublepage
\addcontentsline{toc}{chapter}{Lista de figuras} % para que aparezca en el indice de contenidos
\listoffigures % indice de figuras





\chapter{CAGA}

\section{Breve descripción de la aplicación}
La aplicación de Confianza Asegurada en Geolocalización de Aseos (C.A.G.A.), consiste en una herramienta que ayudará a sus usuarios a localizar aseos. De forma que, en casos en los que uno no se encuentra en casa o en una zona desconocida, se pueda recurrir a esta aplicación para buscar un aseo que satisfaga las necesidades de la persona, ya sean el estado de limpieza, la accesibilidad, el coste de uso del servicio, etc.

\section{Análisis de Stakeholders (Optativo)}

En este apartado hemos decidido dividir en varios grupos a los posibles interesados en nuestra aplicación:

\begin{enumerate}
  \item Usuarios finales: en este grupo se encuentran todos los individuos que pensamos que pueden estar más interesados en nuestro servicio, aquí incluimos tanto a turistas, ya que se mueven por zonas desconocidas; como a personas con necesidades especiales, personas mayores de movilidad reducida, personas con algún tipo de discapacidad, madres que necesitan un lugar para asear a su bebé.
  \item Establecimientos: locales como bares, restaurantes, gasolineras, tiendas, o incluso centros comerciales; se pueden ver beneficiados de esta aplicación, siendo un punto atracción para potenciales clientes.
  \item Anunciantes: la aplicación también puede resultar útil para que ciertas marcas promocionen sus productos entre los usuarios. Ya que se trata de un servicio de búsqueda de aseos, los anunciantes serían principalmente productos de higiene.
\end{enumerate}

\section{Análisis competencia}

Hemos hecho un análisis de varias aplicaciones similares a nuestro proyecto. De cada una hemos intentado obtener los mejores puntos para imitarlos, y los peores, para evitarlos:

\begin{figure}[H]
\centering
\noindent\makebox[\textwidth]{\includegraphics[width=0.75\paperwidth]{img/image1.png}}
\caption{Flush - Public Toilet Finder} \label{fig:image1}
\end{figure}

En esta aplicación, encontramos una interfaz bastante sencilla y que nos indica directamente la información que nos puede interesar al buscar un aseo, sin embargo las imágenes que ofrece de los aseos son poco útiles, te pueden servir para orientarte mínimamente, pero no indican dónde está exactamente el aseo, ni las condiciones en las que se encuentra.


Leyendo las reseñas, también nos damos cuenta que la información se encuentra bastante desactualizada, y a los usuarios les gustaría que los aportes de la comunidad se tengan más en cuenta.

\textbf{OstomiAseo:}


\begin{figure}[H]
\centering
\noindent\makebox[\textwidth]{\includegraphics[width=0.75\paperwidth]{img/image2.png}}
\caption{OstomiAseo} \label{fig:image1}
\end{figure}

\newpage


Similar a la aplicación anterior, esta implementa el horario de cada aseo. Los problemas que encontramos son los mismos. Al ser una aplicación menos conocida, y con menos comentarios, no obtenemos nada relevante de las reseñas

\begin{figure}[H]
\centering
\noindent\makebox[\textwidth]{\includegraphics[width=0.75\paperwidth]{img/image3.png}}
\caption{Toilet Finder} \label{fig:image1}
\end{figure}

\newpage


\section{Definición de objetivos: Plantilla estrategia de diseño. Cinco tareas clave.}

Nuestros objetivos principales con el desarrollo de esta aplicación son:

\begin{itemize}
  \item Solucionar la falta de señalización en la vía pública para encontrar aseos.
  \item Asegurar un mínimo de comodidad y seguridad a los usuarios de nuestra aplicación.
  \item Ayudar a aquellas personas con necesidades concretas a la hora de acceder a un aseo.
\end{itemize}

Para cumplir estos objetivos, vamos a seguir la siguiente estructura para diseñar nuestra aplicación:

\begin{itemize}
  \item Usuario objetivo: el usuario principal al que va a ir dirigida nuestra aplicación serán los turistas, ya que suelen desplazarse por lugares desconocidos para ellos.
  \item Problema a solucionar: como ya se ha mencionado en los objetivos principales, buscamos facilitar la búsqueda de aseos en lugares desconocidos y poco señalizados.
  \item Solución propuesta: con nuestra aplicación, los usuarios podrán ver la ubicación y calificación de cada aseo, para poder elegir el que más les interese según su situación.
  \item Principios de diseño: crearemos una interfaz amigable que permita a los usuarios acceder a la información que buscan rápidamente.
  \item Métricas de éxito: un incremento en la cantidad de usuarios que califican aseos y añaden información a la base de datos.
\end{itemize}

Por último, las tareas clave de nuestra aplicación van a ser:

\begin{enumerate}
  \item Investigación de usuarios
  \item Creación de prototipos
  \item Implementación
  \item Pruebas de usabilidad
  \item Optimización del sistema
\end{enumerate}

\section{Conversión de al menos 3 KI a 3 medidas de ROI}

(Donde al menos una se refiere a eficiencia/efectividad/satisfacción de los usuarios utilizando la aplicación.)


Tras un breve análisis y debate, hemos decidido que nuestros KI van a ser:

\begin{itemize}
  \item Número de descargas de la app
  \item Promedio de satisfacción de los usuarios
  \item Número de baños añadidos por los usuarios
  \item Tiempo de búsqueda de un baño
\end{itemize}

Donde cada ROI sería, respectivamente:

\begin{itemize}
  \item Incremento en monetización o impacto publicitario --> ROI = Ingresos por publicidad / Coste de atracción del usuario
\end{itemize}

\begin{itemize}
  \item Aumento en la recomendación de la app --> Usuarios nuevos por popularización de la app / Gastos en publicidad
\end{itemize}

\begin{itemize}
  \item Incremento de los datos son coste--> ROI = Ahorro en actualizaciones de la base de datos / Coste de animar a los usuarios a hacerlo
\end{itemize}

\begin{itemize}
  \item Tiempo de búsqueda de una baño --> ROI = Tiempo ahorrado por usuario / Coste de optimización de la app
\end{itemize}

\newpage

\section{Definición de grupos de usuario (todos) con una breve descripción}

Para este apartado vamos a desglosar los grupos que teníamos en la sección de stakeholders:

1-. Usuarios locales: personas que viven en la zona en la que buscan baño y pasan mucho tiempo fuera de casa debido a trabajo o aficiones. Utilizan la aplicación por rapidez.

\begin{figure}[H]
\centering
\noindent\makebox[\textwidth]{\includegraphics[width=0.20\paperwidth]{img/image4.png}}
\caption{Usuario local} \label{fig:image4}
\end{figure}

2-. Turistas: personas que no son de la zona, dependen de la aplicación para encontrar un baño. Este grupo le da mayor importancia a la comodidad del servicio en comparación al resto.

\begin{figure}[H]
\centering
\noindent\makebox[\textwidth]{\includegraphics[width=0.20\paperwidth]{img/image5.png}}
\caption{Turistas} \label{fig:image5}
\end{figure}

3-. Personas con necesidades concretas: personas que requieren de una necesidad que puede no estar en todos los baños. Ejemplos serían personas con movilidad reducida como personas mayores o personas en silla de ruedas; padres y madres que buscan asear a su bebé también estarían incluidos en este grupo.

\begin{figure}[H]
\centering
\noindent\makebox[\textwidth]{\includegraphics[width=0.20\paperwidth]{img/image6.png}}
\caption{Personas con necesidades concretas} \label{fig:image6}
\end{figure}

4-. Transportistas y conductores: personas que trabajan en la carretera y que se mueven por zonas como gasolineras o estaciones de servicio. Para este grupo es importante marcar el horario de los aseos, ya que pueden requerir usarlos a altas horas de la noche.

\begin{figure}[H]
\centering
\noindent\makebox[\textwidth]{\includegraphics[width=0.20\paperwidth]{img/image7.png}}
\caption{Transportistas y conductores} \label{fig:image7}
\end{figure}

5-. Asistentes a eventos especiales: personas que asisten a eventos como conciertos pueden buscar evitar los aseos que proporciona el evento debido a su falta de comodidad e higiene.

\begin{figure}[H]
\centering
\noindent\makebox[\textwidth]{\includegraphics[width=0.20\paperwidth]{img/image8.png}}
\caption{Transportistas y conductores} \label{fig:image8}
\end{figure}

6-. Establecimientos: Ya mencionados como stakeholders, las tiendas, bares, restaurantes, e incluso control comerciales, pueden aprovechar la aplicación para atraer potenciales clientes.


\section{Elección de un grupo de usuarios}

Como grupo principal de usuarios hemos seleccionado a los turistas, ya que se trata de un grupo grande de usuarios potenciales, cualquier persona que visite una zona desconocida para ella se puede incluir en este grupo; y, además, se trata de un grupo más fácil de testear con usuarios finales que el de usuarios con necesidades concretas, por ejemplo:

\begin{itemize}
  \item \textbf{Customer jobs}
\end{itemize}


Para los customer jobs, hemos definido las siguientes cinco actividades:

\begin{enumerate}
  \item Buscar un aseo
  \item Publicar un aseo
  \item Calificar un aseo
  \item Ver detalles de un aseo
  \item Ver perfil
\end{enumerate}

Consideramos que son las actividades más importantes que debe poder realizar un usuario sin complicarse lo más mínimo.

\begin{itemize}
  \item \textbf{Puntos de dolor}
\end{itemize}


Poniéndonos en el punto de vista de una persona en un lugar desconocido, creemos que los mayores problemas que podemos encontrar son:

\begin{enumerate}
  \item Falta de información
  \item Falta de baños gratuitos
  \item Baños en mal estado
  \item Baños inseguros
  \item Barreras de idioma
\end{enumerate}

\newpage

\begin{itemize}
  \item \textbf{Desired gains}
\end{itemize}

Basándonos en los anteriores puntos de dolor, las mayores mejoras que un turista puede obtener con nuestra aplicación son.

\begin{enumerate}
  \item Información fiable
  \item Información actualizada
  \item Mapa interactivo
  \item Calificaciones y reseñas de los aseos
  \item Traducción del texto o iconos representativos que lo sustituyan
\end{enumerate}


\begin{itemize}
  \item \textbf{Perfil de usuario}
\end{itemize}

Como usuario principal, definiremos a una persona que viaja mucho, prefiere soluciones digitales y odia perder el tiempo. A esta persona prefiere ir a baños limpios y seguros, y odia tener que ir entrando a bares y que le obliguen a consumir para poder acceder al aseo.

\begin{itemize}
  \item \textbf{Perfil de tarea}
\end{itemize}

En este apartado vamos a clasificar las tareas que ya hemos definido anteriormente según su importancia  y frecuencia de uso:

\begin{figure}[H]
\centering
\noindent\makebox[\textwidth]{\includegraphics[width=0.75\paperwidth]{img/image9.png}}
\caption{Tabla para el perfil de tareas} \label{fig:image9}
\end{figure}

\begin{itemize}
  \item \textbf{Perfil de entorno}
\end{itemize}

El entorno de nuestra aplicación puede ser muy variado, desde una ciudad como Madrid a una zona más rural.

\section{Definición de una Persona (Primaria) que resuma la información de los tres perfiles}

\begin{itemize}
  \item \textbf{Nombre}: Ana García
  \item \textbf{Edad}: 27 años
  \item \textbf{Ocupación}: Diseñadora 
  \item \textbf{Ubicación}: España (viaja constantemente por trabajo y ocio)
\end{itemize}

\textbf{Descripción}


Ana es una viajera frecuente que recorre diferentes ciudades por turismo y trabajo remoto. Planea sus recorridos con aplicaciones móviles y depende de la tecnología para moverse con facilidad. No habla todos los idiomas de los países que visita, por lo que prefiere apps intuitivas y con información confiable en tiempo real.

\textbf{Motivaciones y Necesidades}

\begin{itemize}
  \item Quiere explorar la ciudad sin preocuparse por encontrar un baño en el momento que lo necesite.
  \item Prefiere baños gratuitos o con opciones accesibles y en buenas condiciones.
  \item Necesita una app que le muestre baños cercanos con reseñas y fotos para evitar sorpresas desagradables.
\end{itemize}

\newpage

\section{Artefactos de síntesis de la experiencia de usuario}

\begin{figure}[H]
\centering
\noindent\makebox[\textwidth]{\includegraphics[width=0.75\paperwidth]{img/image10.png}}
\caption{Mapa de empatía de la app} \label{fig:image10}
\end{figure}

\begin{itemize}
  \item \textbf{Cinco escenarios de uso}
\end{itemize}

\begin{itemize}
  \item Buscar un aseo
    \begin{itemize}
      \item Ana está en el centro de una ciudad desconocida y siente urgencia por encontrar un baño, abre la app y ve un mapa con baños cercanos. Selecciona el más próximo con buenas reseñas y sigue la ruta guiada.
    \end{itemize}
  \item Publicar un aseo
    \begin{itemize}
      \item Ana estaba de camino a un aseo de la aplicación, pero se encuentra otro aseo de camino al anterior que no estaba marcado en la app, por lo que decide añadirlo.
    \end{itemize}
  \item Calificar un aseo
    \begin{itemize}
      \item Tras usar un aseo que estaba mal calificado, ya que no podía ir a ningún otro, Ana decide dejar una reseña al baño, ya que no estaba en tan malas condiciones como especificaba la aplicación.
    \end{itemize}
  \item Ver detalles de un aseo
    \begin{itemize}
      \item Ana encuentra un aseo con calificaciones intermedias (ni buenas ni malas), por lo que decide investigar qué problemas hay con ese aseo antes de utilizarlo.
    \end{itemize}
  \item Encontrar un baño gratuito
    \begin{itemize}
      \item Ana no quiere gastar más dinero en su viaje, por lo que busca un aseo en la app que esté señalizado como gratuito.
    \end{itemize}
\end{itemize}

\newpage


\begin{itemize}
  \item \textbf{User journey maps}
\end{itemize}



\begin{figure}[H]
\centering
\noindent\makebox[\textwidth]{\includegraphics[width=0.75\paperwidth]{img/image11.png}}
\caption{User journey map para la tarea 'Encontrar un baño cercano'} \label{fig:image11}
\end{figure}

\begin{itemize}
  \item \textbf{User flow}
\end{itemize}

Para "Encontrar un baño cercano", el flujo sería:

\begin{enumerate}
  \item Abrir la app.
  \item Ver mapa con baños cercanos.
  \item Seleccionar un baño.
  \item Ver detalles (reseñas, fotos, ruta, horario).
  \item Seguir la ruta hasta el baño.
  \item Dejar una reseña (opcional).
\end{enumerate}

\newpage

\section{Prototipado: wireflows de los dos prototipos del equipo.}



\begin{itemize}
  \item \textbf{Prototipo 1 (Realizado por Haytam, Cristian y Daniel)}
\end{itemize}

Para empezar hemos hecho uso mucho de los overflows, ya que queríamos darle un efecto más fluido y más en movimiento al usuario, sobre todo aprovechando un formato tan simple que cualquier usuario de cualquier edad con un mínimo de conocimiento pueda utilizar esta app.

\begin{itemize}
  \item \textbf{Pantalla de favoritos:} Tenemos una funcionalidad de favoritos, la cual trata de poder agregar distintos aseos en un apartado “Favoritos”, para poder acceder a ellos de forma rápida y desde cualquier lado. De este modo, no hará falta buscar todo el rato los mismos baños, ya que si se actualiza el aseo, ya sea porque no esté disponible o por algún cambio, se le mostrará en este apartado.
  \item \textbf{Pantalla de comentarios:} Se ha dado a los usuarios la posibilidad de poner sus opiniones sobre cada aseo, proporcionando un mejor feedback.
  \item \textbf{Registro de aseo:} Se ha habilitado la opción para que los usuarios puedan añadir un aseo que no exista en la base de datos. Este registro será revisado para comprobar la veracidad de la petición, e incluirá información como tipos de baños, días de apertura, horas de apertura y unas fotos del aseo.
  \item \textbf{Modificación de perfil:} El usuario podrá modificar su información personal cuando lo desee.
  \item \textbf{Valoraciones:} Se ofrece una forma adicional de feedback a través de una valoración con estrellas (de 1 a 5), la cual se mostrará como la media de todas las valoraciones de ese baño.
\end{itemize}


\newpage


\begin{itemize}
  \item \textbf{Página principal (Home):} Se compone de dos buscadores: el primero busca por la dirección que introduce el usuario y el segundo por la ubicación desde su teléfono; añadir aseos y un pequeño contenedor para anuncios de la app.
  \item \textbf{Información de baño:} En la información de baño aparecen las siguientes características: Dirección de la ubicación del baño, calificación en estrellas, mapa (Google Maps), preferencias (características del baño), horarios de apertura y un botón de editar.
  \item \textbf{Crear/Editar:} Para crear un baño tendrás que introducir las siguientes casillas: dirección del baño, preferencias del baño y horarios (semana + hora inicio-hora-final). En los horarios puedes seleccionar que el baño esté todos los días abierto y/o todo un día abierto (24h).
  \item \textbf{Editar perfil:} El usuario podrá editar su nombre y email. También podrá observar los baños que ha creado el usuario.
  \item \textbf{Ajustes:} Preferencias de búsqueda. Estos ajustes están basados en unos filtros donde el usuario podrá buscar por las preferencias que desee. Por ejemplo, si el usuario necesita un baño para minusválidos, puede seleccionar dicha preferencia y la app empezará a buscar aseos con esa característica.
\end{itemize}

\newpage


\section{Sección Uso de la IA}

En este documento, chat GPT ha intervenido en los  siguientes puntos:

\begin{enumerate}
  \item \textbf{Análisis de la competencia:} se le ha preguntado a la IA por aplicaciones existentes, para simplificar la búsqueda. Una vez conocíamos las aplicaciones, hemos investigado un poco de estas en la Play Store y hemos seleccionado las que más nos aportan.
  \item \textbf{Fórmulas de los ROI:} en algunos casos teníamos dudas de cómo sería la fórmula para calcular el ROI y hemos recurrido a la IA.
  \item \textbf{Definición de grupos de usuarios:} una vez tenemos definidos los grupos principales, le hemos preguntado a la IA por los grupos que tendría en cuenta para este tipo de app. La IA nos ha dado la idea de implementar los grupos de transportistas y asistentes a eventos especiales.
  \item \textbf{Definición de una persona:} el perfil de Ana lo ha creado chat GPT, le hemos preguntado por el perfil de una persona y hemos adaptado su respuesta para añadirla al documento.
  \item \textbf{Escenarios de uso:} en este caso no se nos ocurrían ideas y hemos recurrido a la IA.
  \item \textbf{Journey map:} aquí no teníamos claro cómo crear el mapa y la IA nos dio la idea de cómo crear la tabla.
\end{enumerate}

Los prompts utilizados han sido los siguientes:

\begin{enumerate}
  \item “¿Conoces alguna aplicación o página web que me ayude a encontrar el aseo disponible más cercano a mi posición actual?”  
        En este caso hemos descartado varias de las aplicaciones que nos ha recomendado, ya que no disponían de mucha información relevante o eran muy similares a otras que sí hemos añadido.
  \item “¿Sabrías decirme como puedo convertir KI a medidas ROI?”  
        En este caso, chat GPT ha creado varios ejemplos que nos han servido para contrastar con lo que ya teníamos, mientras que le pedimos más ejemplos con el prompt “¿Puedes añadir algún ejemplo más?”.
  \item “¿Podrías ayudarme a definir los posibles grupos de usuarios? Añade una breve descripción a cada grupo.”  
        De aquí sacamos las ideas mencionadas anteriormente, mientras que descartamos otros grupos como oficinistas, usuarios de transporte público o estudiantes.
  \item “Ayúdame a definir una persona que resuma la información de los tres perfiles de la aplicación.”  
        De aquí sacamos a Ana, para la que hemos adaptado el perfil que nos ha dado chat GPT, ya que nos daba un perfil mucho más detallado de los que hemos añadido al documento.
  \item “¿Qué escenarios de uso le ves a la aplicación? Evita el login”  
        De aquí hemos descartado ideas como “Buscar un aseo sin conexión a Internet”.
  \item “¿Cómo harías un journey map para la aplicación?”
\end{enumerate}












\chapter{Tecnologías utilizadas}\label{marcoteorico}

\section{OpenMusic}

OpenMusic \cite{openmusic} es un entorno de programación visual orientado a objetos basado en Common Lisp. Se puede utilizar como entorno de programación visual para programación en Lisp ya que implementa la mayoría de construcciones del lenguaje Common Lisp (condicionales, bucles o gestión de listas). Además de añadir un conjunto de estructuras y objetos musicales como acordes, secuencias de acordes, ritmos... Tamién incluye herramientas de reproducción MIDI, análisis de ficheros de sonido, representación de objetos 3D...

Este entorno fue diseñado en el IRCAM (Institut de Recherche et Coordination Acoustique/Musique) en 1998 y lanzado bajo licencia LGPL. Funciona bajo Windows, OS X y en los últimos meses se han empezado a publicar versiones para GNU/Linux. Al ser un software desarrollado en el IRCAM, que es una institución muy importante en el ámbito de la música por ordenador, existe una gran comunidad de usuarios, entre ellos,  muchos compositores de música contemporánea.

\begin{figure}
\centering
\includegraphics[width=0.8\textwidth]{img/Om_patch.png} 
\caption{Ejemplo de programa escrito en OpenMusic. \cite{wiki:openmusic}} \label{fig:openmusic}
\end{figure}


De hecho, los siguientes compositores han reconocido utilizar OpenMusic \cite{wiki:openmusic}:

\begin{itemize}
\item Alain Bancquart
\item Brian Ferneyhough
\item Joshua Fineberg
\item Karim Haddad
\item Eres Holz
\item Michael Jarrell
\item Fabien Lévy
\item Fang Man
\item Philippe Manoury
\item Tristan Murail
\item Kaija Saariaho
\item Marco Stroppa
\end{itemize}

Es por ello muy interesante la posibilidad de desarrollar software como este asistente de música dodecafónica bajo OpenMusic y publicarlo para que personas interesadas como las mencionadas arriba puedan utilizarlo libremente y mejorarlo.

\section{Lisp}
Lisp es una familia de lenguajes de programación multiparadigma basados en listas y con notación basada en paréntesis creada por John McCarthy en 1958 en el MIT (Massachusetts Institute of Technology). El nombre de LISP deriva de ``LISt Processing'', dado que la estructura más importante del lenguaje es la lista (el código fuente de Lisp está compuesto por listas).\cite{wiki:lisp} Se popularizó en los entornos de la inteligencia artificial y fue pionero en conceptos de la ciencia de la computación como las estructuras de árboles o los tipos dinámicos.

Es el segundo lenguaje de alto nivel más viejo con alto uso hoy en día, por detrás de FORTRAN. Los dialectos más conocidos de esta familia son Scheme y Common Lisp.

La sintaxis del código se basa en expresiones S, donde el primer elemento después del paréntesis izquierdo es el nombre de la función y el resto de elementos son los argumentos. Por ejemplo:

\lstset{language=Lisp}
\begin{lstlisting}
(+ 1 3 (* 4 5))
; Output: 24
\end{lstlisting}


\subsection{Common Lisp}
Common Lisp es un dialecto de Lisp estandarizado por la ANSI (American National Standards Institute) creado para estandarizar las variantes de Lisp. Es un lenguaje de propósito general y multiparadigma: combina los paradigmas procedural, funcional y orientada a objetos. Al ser un lenguaje dinámico (los comportamientos del lenguaje se producen en tiempo de ejecución) facilita el desarrollo de software de forma incremental. Existen diferentes implementaciones del estándar, tanto de código abierto como propietarios. \cite{wiki:commonlisp} 

\section{Python}
Es un lenguaje de programación interpretado, multiparadigma (orientado a objetos, imperativo y funcional), tipado débil, multiplataforma y de código abierto (Licencia PSFL). La filosofía de este lenguaje es la de una sintaxis preparada para hacer un código legible y sencillo.

\section{QT}
QT es un framework para aplicaciones multiplataforma utilizado para el desarrollo de interfaces gráficas en proyectos software o también programas sin interfaz para consola y consolas para servidores. También es software libre (bajo licencia GPLv3). El proyecto se hizo famoso en el desarrollo del entorno KDE y con el desarrollo de empresas como Nokia.

\section{PyQt}
La unión de los dos proyectos anteriores se conoce como PyQt4, que aprovecha el conjunto de clases de Qt para crear una interfaz y las herramientas de diseño que incorpora y la simplicidad y posibilidad del uso de objetos del código de Python, además de ser un lenguaje que no necesita un ciclo de \emph{edición/compilación/linkeado/ejecución}, por lo que aumenta la productividad. Además, como las dos herramientas en las que está basado el proyecto es multiplataforma, lo convierte también en multiplataforma. Todo este conjunto de características hace que sea el complemento perfecto para crear interfaces y scripts rápidos para programas de OpenMusic.


\chapter{Cuerpo del trabajo}\label{cuerpo}
\section{Esquema del sistema}
El asistente de composición de música dodecafónica viene estructurado por 5 capas de software: la interfaz con Qt4, el script de generación de parámetros en Python3, el ``patch'' en OpenMusic (mayoritariamente código de Common Lisp) para la generación de la serie, el programa en OpenMusic para la generación de la partitura en OpenMusic y la visualización de la partitura completa en un visor externo (ya desarrollado, como puede ser Finale Notepad, que es gratuito y compatible con la versión del formato MusicXML que exporta OpenMusic).

\begin{figure}
\centering
\noindent\makebox[\textwidth]{\includegraphics[width=0.9\paperwidth]{img/software_diagram.png}}
\caption{Diagrama del diseño del asistente.} \label{fig:softwarediagram}
\end{figure}

\subsection{Interfaz gráfica}

La interfaz en Qt4 se ha diseñado utilizando Qt4 Designer, herramienta incluida en la instalación de Qt4 en el sistema y que permite utilizar todas las herramientas de Qt4 en un editor ``click and drop'', pudiendo ver el resultado de la interfaz sin siquiera saber bajo qué código se va a ejecutar.

\begin{figure}
\centering
\includegraphics[width=\textwidth]{img/qtprogram.png}
\caption{Interfaz en Qt bajo Windows 7} \label{fig:qtinterface}
\end{figure}

El fichero que se obtiene del editor Qt4 Designer es un .ui, que con la herramienta pyuic4 (Python-UI converter 4) convertimos el fichero .ui obtenido en un fichero de Python. Dado que la herramienta pyuic4 muestra por pantalla el resultado, se ha de ejecutar con el símbolo ``>'' después del argumento del fichero a convertir para guardarlo en un fichero .py. El comando en Windows es (suponiendo que estamos en la carpeta con los dos ficheros a utilizar):

   \lstset{language=Bash,
           basicstyle=\ttfamily\scriptsize,
           keywordstyle=\ttfamily,
           stringstyle=\ttfamily,
           commentstyle=\ttfamily,
          breaklines=true
          }
\begin{lstlisting}
pyuic4.bat RuleTranslator.ui > RuleTranslatorInterface.py
\end{lstlisting}

Este fichero es cargado por el script en Python y se le llama con las directivas propias de Qt4 en Python3. Carga la interfaz, convierte los valores de la interfaz en números y los agrupa en forma de lista antes de exportarlos a dos ficheros de texto para que OpenMusic los pueda abrir y procesar. En el código fuente se puede ver claramente cómo funciona este sencillo script.

La interfaz presenta una serie de parámetros como se puede ver en la figura \ref{fig:qtinterface}. El significado de las restricciones que se introducen son:

Parámetros de la serie:
\begin{itemize}
\item máximo y mínimo intervalo de notas en la serie base (en semitonos)
\item la serie base sobre la cual aplicar las restricciones anteriores para obtener una serie final (si existiese)
\end{itemize}

Parámetros de la partitura:
\begin{itemize}
\item número de series que aparecen en una voz (determinando en parte su longitud)
\item porcentaje de notas (para generar también silencios)
\item \emph{threshold} para cambiar de octava (para saltar desde muy rápidamente a muy lentamente)
\item octavas máximas y mínimas (desde Do2 hasta Do4)
\item número de voces de la partitura, compás (2/4, 3/4, 4/4, 3/8, 6/8, 2/1...)
\item máximo y mínimo valor para la reducción y ampliación (sirve para que el compositor pueda bloquear una voz ya generada y ver cómo puede quedar reduciendo o ampliando los tamaños de las notas)
\item división máxima (siendo 8 la semicorchea, 4 la corchea, 2 la negra...)
\item dimensión de las figuras máximas y mínimas (para un valor de factor de aplicación y reducción de 2, 4 es una corchea, 8 es una negra...)
\item un threshold para el transporte (a mayor valor, menos transporte se utiliza, es decir, más se utilizan las series básicas P, I, R, RI).
\end{itemize}

Una vez introducidos los parámetros deseados, se clica sobre el botón ``Get Parameters'' para exportarlos al fichero que leerá OpenMusic.

\begin{figure}[H]
\centering
\includegraphics[width=\textwidth]{img/backtracking.png}
\caption{Esquema recursivo del backtracking, apuntes de la asignatura Análisis y Diseño de Algoritmos} \label{fig:backtracking}
\end{figure}



\newpage

\subsection{Generador de series}
Una vez hemos obtenido los parámetros del compositor, se cargan con el método de lectura de ficheros de OpenMusic y se convierten con un método de Lisp llamado \emph{read-from-string}. El método encargado de la generación de la serie basándose en las restricciones de mínimo y máximo salto de semitonos y en la serie semilla (introducidos por la interfaz) es el método escrito en Common Lisp \emph{seriesGenerator} (empaquetado en forma de librería para hacerlo más accesible y reutilizable en otros proyectos).




Este código ha sido diseñado para obtener una solución siempre que sea posible dadas las restricciones utilizando backtracking en una implementación recursiva.

Backtracking es una estrategia para encontrar soluciones a problemas que satisfacen restricciones. En su forma básica, la idea de backtracking se asemeja a un recorrido en profundidad dentro de un grafo dirigido (que suele ser un árbol). El recorrido tiene éxito si se puede definir por completo una solución. En este caso el algoritmo puede, o bien detenerse (si lo único que se necesita es una solución del problema, que es el caso del método generador de series) o bien seguir buscando soluciones alternativas (si deseamos examinarlas todas). \cite{wiki:backtracking}


El esquema del algoritmo diseñado (algoritmo \ref{esquemalisp}) se basa en el esquema recursivo del backtracking (figura \ref{fig:backtracking}).


\begin{algorithm}
    \KwData {Restricciones de intervalos y serie parcial}
	\KwResult{Serie parcialmente completa}
    Obtiene las notas que faltan en la secuencia parcial y las guarda en una lista llamada notasfaltan
    
    Reordenar aleatoriamente notasfaltan

  	\For{cada elemento en notasfaltan}{
      Creamos una copia para no modificar la lista original
      
      Seleccionar nueva nota y comprobamos si cumple las restricciones
      
      Obtener posicion del primer cero (elemento a rellenar en la semilla)
      
      \If{es la primera posicion de la lista} 
      	  {No se mira el elemento anterior porque no hay
      	  
          Llama recursivamente a seriesGenerator con la nueva lista
          
          \If{seriesGenerator devuelve una lista completa}{
          	  \Return lista
          	}
		  }
		\Else{
          Miramos las restricciones respecto a la nota anterior
          
          \If{las dos notas cumplen las restricciones}
          {Asigna la nueva nota en la posicion del primer cero (hueco en la semilla)
          
          Llama recursivamente a seriesGenerator con la nueva lista
          
          \If{seriesGenerator devuelve una lista completa}{
            \Return lista
           }
          }
              }

	}


  \If{ninguna nota cumple las restricciones}{
  	\Return{lista vacía}
  	}
 \caption{Esquema del generador de series implementado con backtracking recursivo} \label{esquemalisp}
\end{algorithm}



Dado que cualquier solución que cumpla las condiciones nos sirve, no recorremos todo el árbol, tan sólo nos desplazamos por el árbol hasta encontrar la primera solución posible.

Para poder ver la implementación en Lisp, abrir el fichero \emph{serieGenerator.lisp} en la librería \emph{twelvetonelib 1.0} dentro del ``workspace'', donde están los fuentes de todos los métodos implementados en Lisp.

Obtenida la serie con este código, procedemos a computar las 4 series básicas (sin trasporte) de la matriz dodecafónica: P, I, R, RI.

La serie P la obtenemos del método anterior y la inversa se obtiene aplicando el método \emph{reverse} de Lisp. Para obtener la serie retrógrada programamos el mismo proceso que el manual.

Existen dos métodos en OpenMusic llamados x->dx y dx->x que devuelven una lista de intervalos de una lista de notas y viceversa. Es decir, si a x->dx se le pasan los valores de las notas en midicents\footnote{Un midicent es una centésima de una unidad MIDI, es decir, de medio tono.} 2000, 2500, 3200 devuelve (500 700), y si a dx->x le pasamos una nota (por ejemplo 1500) y los valores obtenidos con el ejemplo de antes (500 700), obtenemos (1500 2000 2700).

Si multiplicamos por -1 el valor de los intervalos (tal y como hacemos a mano, ya que si un intervalo es de X semitonos ascendente en la serie original, la inversa son X semitonos descendente) obtenemos la serie inversa y si le aplicamos el método \emph{reverse} tenemos la retrógrada inversa.

Este proceso está programado en un ``patch'' de OpenMusic dado que visualmente es sencillo de programar. En el proyecto de OM se llama \emph{12rmatgen}.

\subsection{Generación de la partitura}
En la generación de una partitura intervienen restricciones introducidas en la interfaz. Estos parámetros se cargan de forma similar que con las restricciones de la serie, sólo que aquí, dado que son 14 parámetros, se ha decidido por crear un ``patch'' interno (un subprograma) dentro del ``patch'' que genera la partitura (\emph{serialscoregenerator}).

La generación de la partitura se procesa a través de varias fases. Partimos de las 4 series generadas con \emph{12rmatgen} (P, I, R, RI). Primero vamos a determinar la longitud de la voz, es decir, cuántas series va a tener una voz. De manera que si una voz tiene dos series, esa voz tendrá una longitud de 24 notas (luego se le añadirán silencios o no y se pondrá un compás y una longitud a esas notas).

En el bucle \emph{longitud y transporte} iteramos tantas veces como se le haya asignado por parámetro, eligiendo una de las series de la matriz de forma aleatoria. El resultado le llega al siguiente bucle que calcula la longitud de las notas. Itera para cada una de las notas de la voz y les asigna un valor de longitud entre los valores pasados por parámetro. Además, con el threshold de silencios, en el caso en el que la función random pase ese threshold, se generarán dos ritmos, uno que será negativo para el silencio (si el valor 1000 para la duración es una figura de negra, un valor de -1000 es un silencio de negra) y uno para la nota que le corresponde en la iteración de la lista. De esta forma, iteramos N veces, siendo N el número de notas, y añadimos silencios según el threshold.

Una vez con la listas de valores de midicents para la voz y de duraciones de las notas, pasamos la lista de duraciones a un objeto característico de OpenMusic: \emph{omquantify}.

Este método se encarga convertir duraciones en milisegundos (tal y como tenemos en la lista de duraciones) en una medida dentro de un compás. Si vemos en el código del generador de partituras, hay dos visualizaciones de los resultados: una sin compás y donde todas las notas son negras (con separaciones diferentes) y una muy cercana a una partitura final.

\begin{figure}
\centering
\includegraphics[width=0.7\textwidth]{img/visores.png}
\caption{Distintas visualizaciones de listas de midicents y duraciones} \label{fig:visores}
\end{figure}

El método \emph{omquantify} recibe cuatro parámetros: la lista de duraciones, el tempo, el compás y la mínima división posible. Estos tres últimos parámetros se leen del fichero obtenido de la interfaz. El tempo hace que una misma duración de una nota se interprete como una nota más larga o más corta. Por ello, se ha interpretado en la interfaz como valor de reducción y ampliación, porque para una misma voz, un valor más alto de reducción y ampliación genera la misma voz pero más larga. 

La mínima subdivisión se establece ya que es un método que traduce milisegundos a medición musical, si establecemos un valor muy bajo (un valor de nota bajo es un número alto, ya que una negra tiene valor 4, una corchea 8, una semicorchea 16, etc.), para valores que no son múltiplos o divisores de negra (siendo el valor de negra 1000 ms en un tempo de negra igual a 60) como puede ser 1002 milisegundos, podría generar fusas, semifusas o valores incluso más bajos indeseados (ya que el método \emph{omquantify} separaría el ejemplo como una negra de 1000 ms y una nota de 2 ms que tal vez no esperamos). MOdificando el valor de la subdivisión, ``redondea'' la nota de 2 ms al valor más próximo.

Finalmente, una vez se haya cuantificado el valor de los tiempos en medición musical, obtenemos un objeto \emph{voice} con esta cuantificación y las notas en midicents. Iteramos tantas veces como voces hayamos especificado y devolvemos el valor a un objeto \emph{score} donde se puede reproducir y editar de forma limitada. También se llama al bucle para exportar para poder visualizarlo en programas profesionales de edición de partituras.

Podemos seguir utilizando el asistente para que nos siga generando ideas acordes con lo que queremos, además aprovechando una de las características de la interfaz de OpenMusic, que es poder bloquear ciertos objetos para que no se vuelvan a calcular. Es decir, por ejemplo, si hemos generado una partitura con una serie que nos satisface, podemos bloquear el objeto de generación de series pulsando sobre él y pulsando la tecla \emph{b} del teclado para que se quede la evaluación previa (aparecerá una X en la esquina superior izquierda del objeto).


\subsection{Uso de los ficheros exportados}
Dadas las limitaciones de OpenMusic y su método de exportación a XML, sólo permite exportar voces individuales a XML, no objetos \emph{score} directamente. Por ello, vemos los ficheros de cada voz exportados en la carpeta \emph{out-files} del workspace. El programa que oficialmente da soporte OpenMusic con XML es Finale. 

Finale es un software propietario de pago para la edición de partituras, pero dispone de un visualizador y editor simple (más avanzado aún así que el editor de partituras de OpenMusic) llamado Finale NotePad. 

En este programa, en el menú \emph{File/MusicXML/Import...} podemos abrir los ficheros y unir todas las voces en una sola partitura creando un nuevo proyecto y moviendo las partituras importadas a las voces del nuevo proyecto.

\begin{figure}
\centering
\includegraphics[width=0.8\textwidth]{img/finale.png}
\caption{Visualización del ejemplo en Finale} \label{fig:finale}
\end{figure}

Finalmente, si quisiéramos exportar este fichero a otro editor con una versión (aquí sí compatible) de MusicXML 3.0 o en fichero MIDI, exportamos o guardamos (respectivamente) y podemos trabajar en el contexto que estemos acostrumbrados a trabajar con partituras.


\begin{figure}
\centering
\includegraphics[width=0.9\textwidth]{img/musescore.png}
\caption{Visualización final del ejemplo en MuseScore} \label{fig:musescore}
\end{figure}

\chapter{Conclusiones}\label{conclusiones}
Tras haber probado el asistente bajo varias condiciones y diferentes parámetros (ejemplos publicados en la carpeta Examples, véase Apéndice \ref{enlaces}), los resultados son satisfactorios, ya que se ha obtenido ayuda e ideas muy interesantes, con lo que se ha obtenido una herramienta musical informatizada complementaria para compositores. El objetivo de conseguir una herramienta que asiste a un músico a componer se ha conseguido aunque se pueden mejorar ciertos aspectos.

El desarrollo de este sistema se ha basado en un modelo incremental, de forma que partíamos de una especificación del proyecto y se ha ido modificando el conjunto de características según avanzamos en las iteraciones o hitos a lo largo del cuatrimestre. Se han realizado reuniones con el tutor para enfocar estos hitos y los diferentes prototipos del proyecto hasta conseguir el prototipo final.

\section{Líneas de trabajo futuras}
Durante el desarrollo de este proyecto han surgido varios problemas de implementación dada la poca experiencia con OpenMusic, haciéndome ver las limitaciones que este programa tiene. El primer planteamiento fue el de implementar el método de generación de series dodecafónicas de forma visual. De hecho, hay gran parte implementado, pero a la hora de programar recursiones, la interfaz da muchos problemas y es mucho más difícil de conseguir que programándolo en Common Lisp. El ``patch'' que se inició a programar también está incluido en el proyecto y se llama \emph{seriegenerator}.

Otro problema existe con el tratamiento de MusicXML. Este estándar para la visualización y guardado de partituras tiene diferentes versiones. OpenMusic tiene implementada una versión antigua que muchos de los editores de partituras no aceptan ficheros con esta codificación. En su página (y como hemos demostrado en el ejemplo) recomiendan Finale, y desde ahí, se permite exportarlo a unos formatos con implementaciones más actualizadas. También ha habido problemas de compatibilidad probando versiones más actualizadas de PyQT (como es PyQT5) pero da problemas con algunos elementos de la interfaz como las señales de activación de funciones, con lo que se decidió utilizar PyQT4, que es más estable.

Durante el desarrollo del proyecto han surgido ideas (tanto programando, como leyendo documentación como hablando con otros músicos) para mejorar el proyecto a largo plazo. Entre esas ideas, existe la posibilidad de programar formas compositivas barrocas y clásicas (estructura A-B-A, contrapuntos por ampliación, reducción, cánon...), desarrollar las series entre voces (es decir, la primera voz puede tener la mitad de una serie y la segunda la otra mitad como se puede ver en la imagen \ref{fig:twelvetoneexample}).

La mayoría de estos métodos implicaría refactorizar el método actual de construcción de partituras, que se basa en generar voces independientes únicamente mirando las series. El problema viene dado por las limitaciones de las clases de OpenMusic y la información del contenido de estas, ya que puede ser muy difícil conseguir, por ejemplo, la longitud de una voz completa en compases ya que la estructura de árbol en Common Lisp con la que está compuesta una voz es muy compleja (al menos actualmente, con la versión \emph{6.8 r4} de OM).

De cualquier manera, tanto el desarrollo de esta aplicación como de la propia base sobre la que se trabaja, OpenMusic, muestran la eficacia del uso de la informática en un entorno musical y abren una puerta a gente con estudios interdisciplinares que quieran mejorar el trabajo y la educación de ambos sectores.

\begin{figure}
\centering
\includegraphics[width=\textwidth]{img/Schoenberg_-_Wind_Quintet_opening.png}
\caption{Ejemplo de composición con la serie dividida en voces\cite{wiki:twelvetonetechnique}} \label{fig:twelvetoneexample}
\end{figure}


\nocite{*}
\cleardoublepage
\addcontentsline{toc}{chapter}{Bibliografía}
\bibliographystyle{apalike}
\bibliography{bibliography}

\appendix
\chapter{Enlaces de descarga}\label{enlaces}
\begin{itemize}

\item Descarga de este documento: \url{https://github.com/Lesbinary/tfg/blob/master/Doc/memoir.pdf?raw=true}

\item Descarga de los fuentes (documentación, proyecto y librería desarrollada): \url{https://github.com/Lesbinary/tfg/archive/master.zip}

\item Enlace al repositorio en Github: \url{https://github.com/Lesbinary/tfg}

\item Enlace a la licencia GPLv3: \url{https://github.com/Lesbinary/tfg/blob/master/LICENSE.txt}

\item Enlace a ejemplos de partituras y audio en MIDI generado por el asistente: \url{https://github.com/Lesbinary/tfg/blob/master/Examples}
\end{itemize}

\appendix
\chapter{Configuración del entorno}\label{aped.A}
Dada la disponibilidad limitada de medios para probar el proyecto (sistemas con GNU/Linux y Windows 7) y que el paquete de GNU/Linux de OpenMusic está aún en fase alpha/beta a fecha de hoy, se explica en este apéndice la configuración del proyecto para el asistente y la librería de la que depende sobre Windows 7.

Accedemos a la página del IRCAM donde están los binarios para descargar: \url{http://forumnet.ircam.fr/shop/fr/forumnet/43-openmusic.html}

Instalamos el paquete con el asistente de instalación. En caso de no tener instalado Python, procedemos a descargarlo de su página web e instalarlo: \url{https://www.python.org/downloads/}

Descargamos el código del asistente (ver apéndice \ref{enlaces}) y veremos que en la raíz está el fichero \emph{RuleTranslator.py}. Se ejecuta (por terminal o con doble click si está convenientemente configurado por el instalador de Python) y podemos exportar unos datos de prueba. Podemos cerrar la interfaz para configurar OpenMusic.

Abrimos OpenMusic y podemos elegir entre crear nuestro ``workspace'' o abrir uno ya existente. Si abrimos el que hemos descomprimido no hay que configurar nada. Vamos a explicar cómo configurar nuestro proyecto suponiendo que tenemos un ``workspace'' alternativo o uno nuevo.

Cuando tengamos nuestro ``workspace'' abierto vamos a configurar la librería de la que depende el asistente. Podemos dirigir OpenMusic a la carpeta del proyecto descomprimido o copiar la librería a nuestro ``workspace'' y dirigir OM ahí. De cualquier manera, la librería está en la carpeta \emph{TFG OM workspace/libraries}. En OpenMusic las librerías de usuario se añaden abriendo en el menú contextual \emph{OM 6.8/Preferences} y añadiendo la ruta donde está la librería y luego seleccionando el checkbox, tal y como se muestra en la imagen \ref{fig:configom}


\begin{figure}
\centering
\includegraphics[width=\textwidth]{img/configom.png}
\caption{Ejemplo de composición con la serie dividida en voces} \label{fig:configom}
\end{figure}

Copiamos los ficheros de \emph{TFG OM workspace/in-files} que son los generados por la interfaz y los movemos a la carpeta in-files de nuestro ``workspace''. Ahora tan sólo tenemos que copiar los ``patches'' que forman el asistente, que están en la carpeta \emph{TFG OM workspace/elements/TFG}. Copiando la carpeta TFG en la carpeta elements de nuestro ``workspace'' será suficiente para que al reiniciar OpenMusic, detecte los nuevos ``patches''.

De esta forma, conseguimos cargar el proyecto del asistente en nuestro ``workspace'' y utilizarlo, modificarlo o crear un asistente derivado en un entorno diferente al adjunto. Para ejecutar el generador de series y el generador de partituras de una sola evaluación, tan sólo hay que evaluar el objeto \emph{and} que hay en el ``patch'' del asistente.


\end{document}
