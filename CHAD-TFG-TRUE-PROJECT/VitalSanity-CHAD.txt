\documentclass[a4paper,twoside,openright,12pt]{book}
\usepackage[
  inner=3cm,      % margen de encuadernación
  outer=2.5cm,    % margen exterior
  top=2.5cm,
  bottom=2.5cm
]{geometry}
\usepackage{setspace}
\onehalfspacing
\setlength{\parskip}{0.75\baselineskip}  % ← prueba con 0.5–1.0 \baselineskip
\setlength{\parindent}{20pt}             % ← conserva la sangría habitual
\raggedbottom 
\usepackage[spanish]{babel}
\usepackage{mathpazo}
\usepackage{graphicx}
\usepackage{caption}
\captionsetup[figure]{skip=10pt, labelfont=bf}
\usepackage[utf8]{inputenc} % Para poner acentos y eñes directamente.
\usepackage{pdfpages}
\usepackage{listings}
\usepackage[T1]{fontenc}

\usepackage[colorlinks=true,
            linkcolor=black,
            citecolor=black,
            urlcolor=black]{hyperref}

\usepackage{algorithm2e}
\usepackage{float} 

\setcounter{tocdepth}{3}
\setcounter{secnumdepth}{3}




\usepackage{fancyhdr}
\pagestyle{fancy}
\fancyhf{}  % limpia encabezados y pies

% Actualiza marks para dos caras
\renewcommand{\chaptermark}[1]{\markboth{\thechapter.\ #1}{}}
\renewcommand{\sectionmark}[1]{\markright{\thesection.\ #1}}

% Cabeceras/pies diferenciados par (E) / impar (O)
\fancyhead[RO]{\thepage}                            % página en el lado derecho impar
\fancyhead[LE]{\thepage}                            % página en el lado izquierdo par
\fancyhead[LO]{\nouppercase{\textit{\rightmark}}}   % sección en impar (izq.)
\fancyhead[RE]{\nouppercase{\textit{\leftmark}}}    % capítulo en par (der.)


\usepackage{titlesec}
\titleformat{\chapter}[display]
  {\normalfont\fontfamily{phv}\selectfont\Huge\bfseries}{}
  {0pt}{\Huge}
\titleformat{\section}
  {\normalfont\fontfamily{phv}\selectfont\Large\bfseries}{\thesection}{1em}{}

\usepackage{courier} % Esto configura \ttfamily a Courier
\lstset{basicstyle=\fontfamily{pcr}\selectfont}

\SetAlFnt{\fontfamily{pcr}\selectfont\footnotesize}




\renewcommand{\textsharp}{$\sharp$}

\begin{document}

\includepdf[pages={1}]{portadas/VitalSanity-Portada.pdf}

\thispagestyle{empty} % para que no se numere esta pagina

\null
\newpage


\includepdf[pages={1}]{portadas/VitalSanity-Second-Portada.pdf}

\thispagestyle{empty} % para que no se numere esta pagina

\null
\newpage

\chapter*{Agradecimientos}

\pagenumbering{arabic}    % ← usa números “normales”
\setcounter{page}{1}      % ← (opcional) empieza en la 1

\markboth{AGRADECIMIENTOS}{AGRADECIMIENTOS} % encabezado
\thispagestyle{empty} % para que no se numere esta pagina

Agradecer este trabajo a mi familia por la ayuda y el apoyo que me han dado para llegar a crear este documento que mezcla dos mundos muchas veces duros de conllevar.

A mi tutor, Carlos, por orientar de una manera sencilla el proyecto y ser honesto con los objetivos propuestos.

A mis compañeros y profesores del grado, con los que he compartido muy buenos momentos y mucha experiencia profesional.

\clearpage                % cierra Agradecimientos
\thispagestyle{empty}     % la página que viene irá SIN cabecera ni pie
\null
\clearpage                % pasa a la siguiente página «normal»

\chapter*{Resumen}

Este trabajo de fin grado implica el desarrollo de una aplicación web llamada \textbf{VitalSanity} cuyo principal objetivo es el de agilizar las \textbf{tramitaciones administrativas rudimentarias} que suelen existir a la hora del tratamiento de la \textbf{información médica de los pacientes} dentro del \textbf{ámbito nacional sanitario español}.

Con \textbf{VitalSanity} se busca establecer un \textbf{historial médico centralizado} para cada paciente, de forma que cualquier profesional médico \textbf{autorizado} pueda acceder a cualquier información del historial, independientmente del centro médico en el que opere el profesional e independientemente de si el profesional médico trabaja en sanidad \textbf{pública} o en sanidad \textbf{privada}.

Para el proceso de autorización se hará uso de la aplicación \textbf{AutoFirma} y de su versión móvil \textbf{Cliente móvil @firma}. Mediante estas herramientas, tanto el profesional médico como el paciente podrán firmar digitalmente autorizaciones con plena \textbf{validez legal} y que garanticen la \textbf{integridad}, la \textbf{autenticidad} y el \textbf{no repudio.} Del mismo modo, también se utilizarán \textbf{AutoFirma} y \textbf{Cliente móvil @firma} para firmar digitalmente los informes agregados por un profesional médico.

Del mismo modo, se incluirán otras medidas como la \textbf{autenticación con certificado digital} o el uso de \textbf{buckets protegidos y privados de AWS} para almacenar todas las autorizaciones y toda la información médica cifrada de forma segura.

Con todo esto se busca establecer un sistema robusto, tanto a nivel de \textbf{seguridad} como a nivel \textbf{legal}, el cual permita cumplir con todo lo referente en \textbf{materia de protección de datos}, tanto con lo establecido en la \textbf{Ley Orgánica de Protección de Datos (LOPDGDD)} de \textbf{España}  como con lo establecido en el \textbf{Reglamento General de Protección de Datos (RGPD)} de la \textbf{Unión Europea}.  



\clearpage                % cierra Agradecimientos
\thispagestyle{empty}     % la página que viene irá SIN cabecera ni pie
\null
\clearpage                % pasa a la siguiente página «normal»


\chapter*{}
\begin{flushright}
  \textit{Cuando cambias la solución, es evolución. \\
          Cuando cambias la pregunta, es revolución.}
  \\[\baselineskip]
  --- Jorge Wagensberg
\end{flushright}


\clearpage                
\thispagestyle{empty}    
\null
\clearpage                


\tableofcontents % indice de contenidos

\cleardoublepage
\listoffigures % indice de figuras


\clearpage                
\thispagestyle{empty}    
\null
\clearpage  

\chapter{Introducción}

\section{Contextualización}

En la actualidad, existe un \textbf{elevado} número de centros médicos que siguen empleando un sistema rudimentario a la hora de tratar con los informes y documentos médicos de sus pacientes. 

Por culpa de este sistema arcaico, los pacientes tienden a encontrarse con graves problemas a la hora de realizar trámites aparentemente sencillos, como lo puede ser el hecho de transmitir \textbf{información} desde un centro médico a otro, acción que esconde un sinfín de elementos burocráticos y papeleo innecesario. 

Toda la complejidad de estas tramitaciones administrativas terminan por sobrepasar la paciencia de los pacientes, perjudicando gravemente a la experiencia y al grado de satisfacción de los mismos.


\section{Justificación del proyecto}

VitalSanity surge como idea innovadora para poder solucionar toda esta situación de descoordinación administrativa dentro del \textbf{ámbito nacional sanitario español.}

La premisa principal es la siguiente: \textbf{ofrecer a los pacientes la posibilidad de autorizar y desautorizar el acceso a su historial clínico centralizado mediante un sistema que resulto sencillo, eficaz y confiable.} 

\section{Sistema de autorización}
Cuando un paciente \textbf{autorice} a un profesional médico, dicho profesional médico tendrá acceso a todo el historial médico del paciente, pudiendo de esta manera visualizar informes y documentos agregados por otros profesionales médicos, así como agregar nuevos informes y documentos médicos propios dentro del historial. 

Con este sistema se logra otorgar una experiencia \textbf{satisfactoria} tanto a los pacientes como a los centros y profesionales médicos, experiencia que consigue agilizar de forma precisa el desorden sistémico presente en los procesos administrativos actuales dentro del ámbito sanitario español.

\section{Introducción a los aspectos legales}


Durante todo momento, la aplicación será desarrollada teniendo en mente como requisito imprescindible la \textbf{protección} y \textbf{seguridad} de todos los datos sensibles tanto de pacientes como de profesionales y centros médicos en \textbf{materia de protección de datos. }

De este modo, se buscará en todo momento cumplir de forma precisa con todo lo establecido en la \textbf{Ley Orgánica de Protección de Datos (LOPDGDD}) en España y con el \textbf{Reglamento General de Protección de Datos (RGPD)}, según lo impuesto en la última actualización de dicha ley dentro del \textbf{BOE}, actualización que se realizó el 9 de mayo de 2023.


Por todo esto, se busca una manera de implementar el sistema de autorizaciones de forma robusta al mismo tiempo que se pretende cumplir con todo lo establecido dentro de La \textbf{Ley Orgánica de Protección de Datos Personales y garantía de los derechos digitales (LOPDGDD)} y con el \textbf{Reglamento General de Protección de Datos (RGPD)}. 

Para ello, se integrará dentro de \textbf{VitalSanity} la aplicación de \textbf{AutoFirma} y la aplicación de \textbf{Cliente móvil @firma }(la versión \textbf{móvil} de \textbf{AutoFirma}). 

\section{AutoFirma y Cliente móvil @firma}
Tanto \textbf{AutoFirma} como \textbf{Cliente móvil @firma} son ambas aplicaciones oficiales desarrolladas por el \textbf{Gobierno de España}, específicamente por el \textbf{Ministerio para la Transformación Digital y de la Función Pública}. Su objetivo principal es facilitar la firma electrónica de documentos y la realización de trámites en línea con las \textbf{Administraciones Públicas}.

\vspace{1em}

\begin{figure}[H]
\centering
\includegraphics[width=0.885\textwidth, height=1\textheight, keepaspectratio]{img/autofirma-logo.jpg}
\caption{Logo oficial de AutoFirma}
\label{autofirma-logo:vv}
\end{figure}

\vspace{1em}

\begin{figure}[H]
\centering
\includegraphics[width=0.25\textwidth, height=0.25\textheight, keepaspectratio]{img/Cliente Movil @firma-logo.jpg}
\caption{Logo oficial de Cliente móvil @firma}
\label{Cliente Movil @firma-logo:vv}
\end{figure}

Ambas aplicaciones cumplen de forma intrínseca con la \textbf{Ley Orgánica de Protección de Datos Personales y garantía de los derechos digitales (LOPDGDD)} y con el \textbf{Reglamento General de Protección de Datos (RGPD)}. 

Al tratarse de herramientas oficiales desarrolladas por el \textbf{Gobierno de España}, ambas aplicaciones están diseñadas para garantizar la seguridad y confidencialidad en el tratamiento de datos personales durante los procesos de firma electrónica. Este es el requisito fundamental y diferenciador por el cual se escoge \textbf{AutoFirma} y \textbf{Cliente móvil @firma }en lugar de implementar un sistema de firma personalizado, puesto que a dicho sistema de firma personalizado prácticamente se le imposibilitaría el cumplir de forma simultánea con la \textbf{LOPDGDD} como con la \textbf{RGPD} al no estar registrado bajo un \textbf{órgano} \textbf{oficial} del \textbf{Gobierno de España}.

De esta manera, tanto \textbf{AutoFirma} como \textbf{Cliente móvil @firma }serán utilizadas para firmar digitalmente los documentos PDF representativos de las autorizaciones para el acceso al \textbf{historial clínico centralizado} del paciente. En dichas autorizaciones entrarán en juego dos firmas digitales: la firma del \textbf{profesional médico} y la firma del \textbf{paciente} (\textbf{cofirma}), de forma que al final se obtendrá un \textbf{PDF} con \textbf{dos firmas diferentes}. 

Estas firmas digitales gozan plena \textbf{validez legal} y además  confieren a los \textbf{documentos firmados} un \textbf{elevado nivel de protección} puesto que aseguran en todo momento: 

\begin{itemize}
    \item \textbf{La} \textbf{integridad}, porque cualquier alteración posterior invalida la firma digital.
    \item \textbf{La} \textbf{autenticidad}, porque se vincula \textbf{criptográficamente} la identidad de los firmantes al documento.
    \item \textbf{El} \textbf{no repudio}, ya que los \textbf{firmantes} no pueden negar la \textbf{autoría} de la firma.
\end{itemize}



Del mismo modo, también se emplearán \textbf{AutoFirma} y \textbf{Cliente móvil @firma }para firmar digitalmente cada uno de los \textbf{informes médicos} subidos por \textbf{los profesionales sanitarios.}

\newpage

\section{Otros aspectos de seguridad}

Por otra parte, también se hará uso de otros mecanismos diferentes para robustecer aún más la \textbf{seguridad} dentro del sistema y la \textbf{integridad} de los datos: \textbf{método de autenticación con certificado digital}, uso de buckets protegidos de \textbf{AWS} mediante \textbf{URLs} \textbf{prefirmadas} para almacenar las \textbf{autorizaciones} y \textbf{los informes médicos}; gestor de claves personalizado \textbf{KMS}, entre otros aspectos.

Para desarrollar la aplicación se hará uso del \textbf{framework} de \textbf{backend} \textbf{Spring Boot}, aprovechando las \textbf{potentes} herramientas de \textbf{seguridad} que ofrece este \textbf{framework} gracias a \textbf{Spring Security} y a su integración nativa con \textbf{X.509}, estándar en base al cual se generan \textbf{todos los certificados electrónico}s en \textbf{España}.


\section{Objetivo principal}

En síntesis, el objetivo \textbf{principal} que pretende \textbf{VitalSanity} es el de desarrollar una aplicación web que permita agilizar los trámites burocráticos y rudimentarios, empleando un \textbf{sistema de autorización} de acceso al historial clíncio centralizado de los pacientes el cual haga uso de la herramienta \textbf{AutoFirma} y \textbf{Cliente móvil @firma }para garantizar la \textbf{seguridad} y la \textbf{confidencialidad} en el tratamiento de \textbf{datos personales}, cumpliendo con todo lo establecido por la \textbf{Ley Orgánica de Protección de Datos Personales y garantía de los derechos digitales (LOPDGDD) }y con el \textbf{Reglamento General de Protección de Datos (RGPD).}

 Por último, cabe destacar que con el objetivo de garantizar el pleno cumplimiento tanto de la \textbf{LOPDGDD como de la RGPD }y dado a que \textbf{AutoFirma} y su versión para \textbf{móviles} son aplicaciones desarrolladas por el \textbf{Gobierno de España}, \textbf{VitalSanity} se limitará en un primer momento a ser una aplicación dentro del \textbf{ámbito nacional español}. Con esto se logra simplificar y garantizar de una forma más segura el cumplimiento de todas las \textbf{normativas legales vigentes} en la actualidad en \textbf{materia de protección de datos.}

 No obstante, esto no descarta en ningún momento la posibilidad de que \textbf{VitalSanity} pueda expandirse en un futuro al \textbf{ámbito internacional.}

 

\chapter{Estado del arte}
\section{Productos similares actualmente en el mercado}
\subsection{HCDSNS - España} 
En España, el Ministerio de Sanidad ha impulsado la HCDSNS (Historia Clínica Digital del Sistema Nacional de Salud) como un repositorio electrónico unificado de información sanitaria esencial, accesible tanto para profesionales autorizados como para los propios ciudadanos.

Esta plataforma nacional permite que un médico en cualquier comunidad autónoma consulte informes clínicos generados en otra región, facilitando la continuidad asistencial en todo el país y evitando pruebas duplicadas. La HCDSNS opera bajo estrictos criterios de seguridad: el acceso requiere autenticación robusta (DNIe, certificados electrónicos o sistema Cl@ve) y queda limitado a fines asistenciales. 


\subsection{Proyecto de Historia Clínica Interoperable - España}
El sector sanitario privado español, aglutinado en la Fundación IDIS, ha desarrollado una plataforma pionera de historia clínica compartida de ámbito nacional para sus pacientes: El Proyecto de Historia Clínica Interoperable en la Sanidad Privada. A finales de 2023 ya contaba con unos\textbf{ 57.000} \textbf{usuarios conectados} y la participación de al menos 15 entidades sanitarias privadas relevantes (grupos hospitalarios y aseguradoras médicas). 

Esta iniciativa permite que un paciente de la sanidad privada \textbf{acceda a su historial clínico unificado} a través de un portal web o aplicación y pueda \textbf{compartir dicha información –totalmente o por informes seleccionados– con el profesional sanitario que él elija}, independientemente del centro u hospital al que pertenezca dicho profesional. 

En cuanto a \textbf{seguridad} de esta aplicación, la directriz es equiparable al sistema público: solo profesionales autorizados pueden acceder, mediante credenciales seguras, y se incorporan mecanismos de alerta ante cualquier intento de acceso no autorizado a datos privados. “Nos tenemos que sentir seguros, confiados”, destacó la Dirección de IDIS al subrayar que se está diseñando un sistema con alertas que saltan si alguien intenta \textbf{invadir un dato privado}, garantizando así la privacidad del paciente. 


\subsection{Epic MyChart - Internacional}
MyChart es la plataforma de portal de pacientes de Epic, que permite consultar medicaciones, resultados de pruebas, citas, facturación y presupuestos de forma centralizada para más de 190 millones de pacientes en múltiples organizaciones sanitarias. Además, incorpora comunicaciones seguras entre paciente y profesional y videovisitas integradas.

\subsection{Cerner Patient Portal - Estados Unidos}
Ofrece acceso al Registro Médico Electrónico (EMR) mantenido por el proveedor, con vistas seguras a informes clínicos y comunicación bidireccional entre paciente y profesional. Dispone de funcionalidades para descargar y compartir registros con otros profesionales.

\subsection{Carpeta Personal de Salud (CPS) AppSalut - Cataluña}
Iniciativa pública que facilita la prescripción e integración de apps sanitarias acreditadas, mostrando gráficos de evolución de datos y permitiendo a profesionales seleccionar información para integrar en la historia clínica. Asimismo, ofrece al ciudadano visualización de datos generados en el sistema público catalán y filtros avanzados.


\subsection{Dossier Médical Partagé (DMP) – Francia}
A nivel europeo, Francia ha implementado desde 2018 el Dossier Médical Partagé, un expediente médico electrónico \textbf{personal y seguro} para cada ciudadano francés. Su objetivo es servir como \textbf{historia clínica digital unificada}: almacena informes médicos, resultados de pruebas, antecedentes de salud, alergias, informes de hospitalización e incluso las voluntades anticipadas del paciente. 

El DMP busca \textbf{mejorar la coordinación y continuidad asistencial }centralizando los datos médicos en un “carné de salud” electrónico accesible en línea. Cada ciudadano puede crear gratuitamente su DMP y gestionar quién tiene acceso: \textbf{el paciente mantiene siempre el control sobre quién consulta su expediente}, pudiendo añadir información personal relevante u \textbf{ocultar determinados documentos} para que no sean visibles a profesionales, según su preferencia. De hecho, el sistema envía notificaciones (por correo electrónico) cada vez que se añade un nuevo documento al expediente, reforzando la transparencia hacia el titular de los datos. 


\subsection{Elektronische Patientenakte (ePA) - Alemania}

En \textbf{Alemania}, se ha introducido la Elektronische Patientenakte, un expediente electrónico del paciente promovido por las aseguradoras públicas, donde el ciudadano puede gestionar sus registros médicos digitales a través de aplicaciones móviles y controlar el acceso de médicos a dichos datos mediante consentimientos específicos. 

\subsection{Expedientes médicos centralizados en Estonia}
En \textbf{Estonia}, todo ciudadano posee un expediente médico digital centralizado: los profesionales sanitarios acceden a la información con autorización, y el paciente puede revisar en un portal quién ha consultado su historial, pudiendo bloquear el acceso a determinados datos si así lo desea (salvo en emergencias).

\section{Objetivos comunes en este tipo de soluciones}
Los ejemplos anteriores, tanto públicos como privados, evidencian una serie de \textbf{objetivos comunes} en las soluciones de historial clínico centralizado y acceso compartido:

\begin{itemize}

\item \textbf{Continuidad asistencial y disponibilidad universal de datos}: Unificar la información médica del paciente para que esté disponible desde \textbf{cualquier centro o región}, evitando fragmentación de datos. Esto permite a cada profesional sanitario autorizado consultar antecedentes relevantes (alergias, medicación, diagnósticos previos) aunque sea la primera vez que atiende al paciente. El acceso unificado reduce la repetición de pruebas diagnósticas innecesarias y mejora la coordinación entre niveles asistenciales, brindando una atención más eficiente y segura.
\item \textbf{Empoderamiento del paciente y control sobre la privacidad: } Poner al paciente en el centro, otorgándole acceso directo a su historia clínica y la capacidad de decidir quién más puede verla. Todas las plataformas coinciden en \textbf{requerir el consentimiento del paciente} para compartir sus datos con terceros, en línea con la normativa de autonomía del paciente.
\item \textbf{Seguridad de la información y cumplimiento legal: } Dada la naturaleza altamente sensible de los datos de salud, estas soluciones comparten el objetivo de garantizar \textbf{la confidencialidad, integridad y disponibilidad} de la información clínica. Implementan autenticación fuerte (certificados digitales, identidades electrónicas verificadas) para el acceso tanto de profesionales como de pacientes, utilizan conexiones cifradas y centros de datos seguros, y se ajustan a las exigencias legales (GDPR en Europa, Ley Orgánica de Protección de Datos y Garantía de Derechos Digitales en España, etc.). La \textbf{trazabilidad} de cada acción (quién accede, cuándo y qué consulta) y la generación de \textbf{alertas ante accesos no autorizados} constituyen prácticas habituales para proteger los datos. Igualmente, se fomenta el almacenamiento seguro de la información, con copias de respaldo y planes de contingencia, para garantizar que el historial clínico centralizado esté disponible incluso ante fallos técnicos o desastres.
\item \textbf{Mejora de la eficiencia y reducción del papel: } Estas aplicaciones digitalizan la documentación clínica redunda en una gestión más ágil y sin papel de los procesos sanitarios. Un objetivo común es eliminar trámites físicos engorrosos: por ejemplo, sustituyendo los consentimientos informados y otros formularios en papel por \textbf{documentos electrónicos firmados digitalmente}. La firma electrónica integrada en estas plataformas permite que pacientes y profesionales firmen autorizaciones, consentimientos o informes de alta de forma \textbf{remota o presencial}, con plena validez legal, quedando el documento almacenado de forma segura en el sistema. 

\end{itemize}


\section{Similitudes con VitalSanity}
Con todo esto, la propuesta de VitalSanity se inscribe en una tendencia clara de digitalización sanitaria centrada en el paciente, compartiendo muchos de los pilares funcionales con las soluciones actuales del mercado. Al igual que las plataformas públicas nacionales (HCDSNS en España, DMP en Francia) y los portales integrados privados, VitalSanity busca ofrecer una historia clínica electrónica centralizada donde el paciente pueda reunir todo su historial médico y ejercer un control activo sobre él. 

Se puede observar de forma evidente que las similitudes son notables: VitalSanity pone énfasis en la autorización por parte del paciente para cualquier acceso a datos (siguiendo el principio de consentimiento informado y gestión granular de la privacidad, como ya implementan HCDSNS o DMP) y promete un almacenamiento seguro de la información sensible, alineado con las mejores prácticas de seguridad y la normativa europea de protección de datos. 

Asimismo, VitalSanity incorpora la firma electrónica de documentos médicos como parte integral de sus funcionalidades, permitiendo digitalizar procesos que en muchos entornos aún se realizan en papel (por ejemplo, la firma de consentimientos informados o la compartición de informes entre profesionales). Este enfoque multidisciplinar –que combina expediente clínico interoperable, portal del paciente y firma digital avanzada– coincide con el objetivo general del sector de lograr una sanidad sin barreras físicas ni administrativas, donde el flujo de información médica sea instantáneo pero siempre bajo el control del titular de los datos.

Ahora bien, no nos podemos olvidar de que VitalSanity también enfrenta el desafío de diferenciarse y aportar valor añadido en un panorama donde ya existen iniciativas consolidadas. Una diferencia potencial radica en el alcance y la integración: mientras las soluciones públicas suelen limitarse al ámbito del sistema regional de salud, y las privadas tienden a circunscribirse a las redes de determinados grupos hospitalarios o aseguradoras, VitalSanity se presenta como una plataforma agnóstica al proveedor, capaz de agregar información de múltiples fuentes (públicas y privadas) en un único expediente longitudinal del paciente. 

Esto supone un nivel extra de interoperabilidad, sirviendo de puente entre silos de información que hoy permanecen parcialmente desconectados. De esta forma, un usuario de VitalSanity puede visualizar en su cuenta tanto los informes de una intervención quirúrgica realizada en un hospital público, como los resultados de unas pruebas diagnósticas efectuadas en una clínica privada, y compartir ambos con su médico de cabecera de forma sencilla.



Por todo lo ya mencionado, VitalSanity se alinea con la dirección en la que evoluciona la sanidad digital, proporcionando funcionalidades que son hoy por hoy indispensables –centralización del historial, acceso multidisciplinar con permiso del paciente, firma electrónica y alta seguridad– y debe competir en confiabilidad, alcance y facilidad de uso con soluciones ya operativas. 

El éxito de VitalSanity depende de su capacidad para igualar y superar los estándares ya marcados por iniciativas públicas y privadas (en términos de seguridad jurídica, interoperabilidad y cumplimiento normativo) y a la vez innovar en ámbitos como la integración total de fuentes de datos y la experiencia de usuario. De lograr este equilibrio, VitalSanity podría aspirar (una vez puesta en producción) a posicionarse sólidamente en el panorama actual, aportando una visión unificada del historial clínico del paciente y anticipándose a las futuras tendencias, donde el paciente empoderado y el intercambio seguro de información constituyen la piedra angular de los sistemas de salud.


\chapter{Tecnologías y herramientas utilizadas}

\section{AutoFirma }

\textbf{AutoFirma} es una \textbf{aplicación de escritorio} desarrollada por el \textbf{Ministerio de Hacienda} y \textbf{Administraciones Públicas de España} para la firma electrónica de documentos, basada en \textbf{software libre} y \textbf{estándares abiertos} que garantizan la \textbf{interoperabilidad} y la \textbf{seguridad} en las transacciones electrónicas.

Forma parte de la suite \textbf{@firma}, un conjunto integral de servicios y herramientas para \textbf{identificación} y \textbf{firma electrónica} que pueden usarse de modo independiente o integrarse en otras aplicaciones.

\textbf{AutoFirma} permite ejecutar operaciones de firma de ficheros en entornos \textbf{Windows, Linux y macOS}, ofreciendo una experiencia simple y accesible para usuarios con o sin conocimientos técnicos avanzados.

La aplicación selecciona automáticamente el formato de firma más apropiado al tipo de documento (\textbf{PDF, XML}, etc.), liberando al usuario de cualquier decisión técnica y permitiendo además la visualización de las firmas y los documentos firmados.

Entre sus beneficios destacan la \textbf{autonomía} del usuario (la clave privada nunca abandona su dispositivo), la \textbf{interoperabilidad} entre diferentes sistemas y el cumplimiento de la \textbf{normativa eIDAS y Ley 39/2015}, lo que asegura \textbf{pleno reconocimiento legal} en toda la \textbf{Unión Europea} y dentro de \textbf{España}.

\textbf{AutoFirma} ha representado la piedra angular de las funcionalidades de \textbf{VitalSanity}, utilizándose para \textbf{firmar/cofirmar} las \textbf{autorizaciones} y para firmar los \textbf{informes médicos}.


\section{Cliente móvil @firma}
Constituye la versión móvil de \textbf{AutoFirma}. Se emplea para realizar operaciones de firma desde dispositivos Android e iOS.

La comunicación entre la página web y \textbf{Cliente móvil @firma} se realiza mediante el uso de servidores intermedios, lo que permite al usuario firmar documentos sin que la clave privada salga de su dispositivo (este aspecto se describirá en más detalle en apartado de \textbf{'Detalles de Implementación'}.

Aunque \textbf{Cliente móvil @firma} comparta muchos rasgos comunes con \textbf{AutoFirma}, a la hora de establecer la integración con una aplicación existen diferencias claves y no triviales entre ambas que deben de tenerse en cuenta.

De igual forma que \textbf{AutoFirma}, \textbf{Cliente móvil @firma} representa una pieza fundamental dentro de VitalSanity. La aplicación se ha desarrollado de tal forma que todos los procesos que involucren una firma se puedan realizar de forma independiente con ambas aplicaciones. 

La razón principal por la que se ha decidido integrar también \textbf{Cliente móvil @firma} ha sido porque los pacientes tenderían a usar la aplicación desde un dispositivo móvil. Por otro lado, los profesionales sanitarios, los centros médicos y los administradores tenderían a utilizar la aplicación desde el ordenador.

\section{Docker}
Docker es una plataforma de código abierto para el desarrollo, envío y ejecución de aplicaciones en contenedores, que aísla las aplicaciones de la infraestructura subyacente para asegurar un despliegue rápido y consistente en entornos locales, centros de datos o proveedores de nube.

Gracias a su arquitectura cliente-servidor, en la que el cliente Docker comunica con el demonio dockerd mediante una API REST, Docker simplifica la gestión del ciclo de vida de contenedores, imágenes, redes y volúmenes.

Entre los principales beneficios de Docker destacan la portabilidad de las aplicaciones, la entrega continua en flujos CI/CD, la escalabilidad dinámica y un uso eficiente de los recursos al ejecutar múltiples contenedores compartiendo el kernel del sistema operativo.

 Los casos de uso más comunes incluyen la adopción de arquitecturas de microservicios, la creación de entornos de prueba reproducibles, la migración de aplicaciones heredadas a entornos containerizados y la automatización de despliegues en prácticas DevOps.

 Docker otorga portabilidad a cualquier aplicación, lo que permite solucionar problemas de configuración local, evitando así el clásico problema de \textbf{'en mi ordenador sí que funcionaba'}.

Para el desarrollo de la aplicación se ha empleado una base de datos \textbf{Postgres dockerizada}


\section{Docker Compose}

Docker Compose es una herramienta incluida en el ecosistema Docker que permite definir y ejecutar aplicaciones compuestas por múltiples contenedores a través de un único fichero YAML (\textit{compose.yml}), desde el cual se pueden desplegar, escalar y gestionar de manera simultánea todos los servicios implicados.

A diferencia de la interfaz de línea de comandos de Docker pura, Docker Compose ofrece comandos especializados (como \textit{docker compose up}, \textit{docker compose down}, \textit{docker compose build} o \textit{docker compose ps}) que facilitan la orquestación de pilas de servicios en hosts únicos, siendo especialmente valiosa para entornos de desarrollo, pruebas automatizadas en CI/CD y despliegues monohost.

Entre sus beneficios destacan la rápida configuración mediante scripts YAML y variables de entorno, la portabilidad de la configuración entre equipos, la comunicación interna segura de los servicios a través de redes aisladas y la eficiencia en el uso de recursos al reutilizar contenedores y caches de configuración.

\textbf{Docker Compose} es una de las herramientas más poderosas que disponemos los programadores en la actualidad puesto que permite levantar una aplicación en cualquier máquina que tenga instalada docker, lo cual evita el tener que descargar manualmente todas las dependencias en cada máquina, aspecto que sin duda ahorra una enorme cantidad de tiempo y muchos quebraderos de cabeza.

Para el desarrollo de la aplicación se ha empleado \textbf{Docker Compose} para orquestar dos servicios: \textbf{app} y \textbf{db}.

\section{Mailtrap}

Mailtrap es una plataforma de pruebas y entrega de correo electrónico que crea un buzón virtual aislado para capturar todos los mensajes enviados desde entornos de desarrollo, evitando así el envío accidental a usuarios reales. Se utiliza principalmente para previsualizar correos en distintos dispositivos, garantizando la fidelidad del diseño antes de su despliegue en producción. 

Entre sus fortalezas destacan la integración con API RESTful y SMTP para automatizar flujos de QA, la detección temprana de errores en el contenido y la posibilidad de realizar pruebas automatizadas en pipelines de CI/CD sin riesgos.

Sus casos de uso más comunes incluyen la verificación de emails de registro, restablecimiento de contraseñas y notificaciones transaccionales.

\textbf{Mailtrap} ha representado un bloque funcional \textbf{muy importante} ya que es ampliamente utilizado en un gran número de funcionalidades de la aplicación, en particular se usa para:

\begin{itemize}
    \item Enviar correo de información al paciente cuando un profesional médico le ha solicitado autorización de acceso a su historial.
    \item Enviar correo de información al profesional médico cuando un paciente ha aceptado la solicitud de autorización.
    \item Enviar correo de información al profesional médico cuando un paciente ha denegado la solicitud de autorización.
    \item Enviar correo de información al profesional médico cuando un paciente ha desautorizado el acceso a su historial médico.
    \item Enviar correo con la clave de acceso cuando un administrador registra a un centro médico.
    \item Cuando un centro médico registra a profesionales médicos a partir de un fichero \textbf{CSV}, enviar correos con las claves de acceso a cada uno de los profesionales médicos registrados.
    \item Cuando un paciente se registra, enviarle correo con el código de confirmación.
\end{itemize}


\section{Spring Boot }
Spring Boot es un framework de código abierto desarrollado por Pivotal que simplifica la creación de aplicaciones Java independientes y listas para producción adoptando convenciones opinadas sobre la configuración del ecosistema Spring.

Spring Boot proporciona arranques automáticos (Starters), autoconfiguración y un servidor embebido que elimina la dependencia de servidores externos.

Los principales beneficios incluyen la reducción de la complejidad en la configuración inicial, la aceleración de los ciclos de desarrollo y la compatibilidad nativa con prácticas de integración y despliegue continuos (CI/CD ), permitiendo así desarrollar aplicaciones empresariales de alta disponibilidad.

Puesto que la seguridad es uno de los aspectos más fundamentales que se busca perseguir con \textbf{VitalSanity}, la principal razón por la que se ha elegido Springboot como framework para desarrollar la aplicación ha sido por \textbf{Spring Security}. 

Spring Security es una herramienta intregada dentro de \textbf{Spring Boot} la cual sirve para dotar a las aplicaciones de una capa muy robusta de seguridad.

Asimismo, también ha sido de gran utilidad su integración nativa con \textbf{X.509}, estándar en base al cual se generan todos los certificados electrónicos oficiales y con plena validez legal en España. Gracias a esto, ha resultado más sencillo integrar AutoFirma/Cliente móvil @firma, así como implementar la autenticación con certificado digital.
 
\chapter{Aspectos de seguridad}


\section{Seguridad en la Firma Digital de Documentos}
La autenticación de usuarios en \textbf{VitalSanity} se realiza mediante certificados digitales \textbf{X.509}, integrados en la plataforma a través de \textbf{Spring Security} y aprovechando la integración \textbf{nativa} de Spring Security con el protocolo \textbf{X.509}. Cada usuario  debe \textbf{identificarse con un certificado digital reconocido} y su correspondiente clave privada, lo que proporciona un nivel alto de seguridad en la verificación de la identidad. En la práctica, esto implica que el sistema solo permite el acceso a quienes posean un certificado válido emitido por una Autoridad de Certificación de confianza (por ejemplo, el DNIe o certificados de la FNMT), aumentando significativamente la protección frente a accesos no autorizados o suplantación de identidad.


Cabe destacar de que en la aplicación también se ha incluido la opción tradicional de iniciar sesión con email y contraseña. Esto se ha realizado para poder realizar las pruebas pertinentes en la aplicación durante desarrollo (debido a que se necesitaba crear múltiples usuarios y trabajar con múltiples usuarios y roles para poder probar todas las funcionalidades de la aplicación). Cabe destacar de que en producción se eliminaría esta opción de iniciar sesión con email y contraseña, imponiendo a los usuarios el autenticarse mediante un certificado digital válido para así defenderse de forma robusta frente a accesos no autorizados o suplantación de identidad, consiguiendo de esta manera una seguridad muy potente a la hora de acceder al sistema.

Por otra parte, la plataforma verifica rigurosamente la validez del certificado presentado en cada inicio de sesión. Este proceso incluye la comprobación de que el certificado \textbf{no haya sido revocado} y que siga siendo \textbf{plenamente válido para identificar a su propietario}. Solo tras superar todas estas verificaciones, Spring Security \textbf{autentica al usuario} y le concede acceso a las funciones de la aplicación. Este mecanismo de autenticación basada en certificados digitales ofrece garantías de seguridad equiparables a la autenticación de múltiples factores, pues requiere algo que el usuario \textbf{posee} (su certificado y clave privada) y algo que el usuario \textbf{es} (su identidad avalada por el certificado). Gracias a ello, VitalSanity asegura que únicamente personas autorizadas puedan acceder a datos sensibles, evitando accesos indebidos incluso en entornos distribuidos o remotos.


\section{Seguridad en la Firma Digital de Documentos}
VitalSanity incorpora el uso de herramientas oficiales de \textbf{firma electrónica} proporcionadas por el Gobierno de España para garantizar la autenticidad e integridad de los documentos clínicos generados en la plataforma. En particular, se utiliza la aplicación \textbf{AutoFirma}, así como su \textbf{cliente móvil @firma}, para la firma digital de autorizaciones de pacientes y de informes médicos emitidos por los profesionales sanitarios. AutoFirma, desarrollada por el Ministerio de Hacienda y Administraciones Públicas, es parte de la suite @firma y permite realizar la firma electrónica de documentos cumpliendo con estándares abiertos, \textbf{garantizando la interoperabilidad y la seguridad en las transacciones electrónicas}. De este modo, cada vez que un médico emite un informe o un paciente otorga una autorización en VitalSanity, el documento correspondiente es firmado digitalmente mediante un certificado electrónico reconocido, usando AutoFirma en entornos de escritorio o el Cliente @firma en dispositivos móviles.


El empleo de \textbf{certificados digitales reconocidos} en la firma confiere a los documentos un alto nivel de protección: \textbf{integridad}, porque cualquier alteración posterior invalida la firma digital; \textbf{autenticidad}, porque vincula criptográficamente la identidad del firmante al documento; y \textbf{no repudio}, ya que el firmante no puede negar la autoría de la firma. Estas propiedades son cruciales tratándose de autorizaciones sanitarias e informes médicos, que requieren la máxima fiabilidad y validez legal. Cabe destacar que las soluciones de la suite @firma están alineadas con la normativa española y europea de firma electrónica (eIDAS), por lo que las firmas generadas a través de AutoFirma gozan de reconocimiento legal equivalente a la firma manuscrita. VitalSanity garantiza que todos los documentos críticos se firman digitalmente de forma segura y \textbf{formalmente válida}, fortaleciendo la confianza en la documentación clínica intercambiada a través de la aplicación.

\section{Protección de los Datos en el Almacenamiento}
En \textbf{VitalSanity}, los datos sensibles (historias clínicas, informes, consentimientos firmados, imágenes médicas, etc.) se almacenan de forma segura utilizando \textbf{Amazon Web Services (AWS)}, concretamente en \textbf{buckets de Amazon S3} dedicados. Estos repositorios de almacenamiento en la nube están configurados como privados y se han implementado controles estrictos para su acceso. La aplicación nunca expone directamente los contenidos almacenados; en su lugar, utiliza \textbf{URLs prefirmadas} de S3 para cualquier acceso a documentos. Una URL prefirmada es un enlace temporal generado por la aplicación que concede acceso limitado a un objeto (archivo) específico en S3, sin necesidad de revelar credenciales o permisos permanentes de AWS. Estas URLs prefirmadas incorporan \textbf{tokens de seguridad y expiración}: solo el usuario autorizado puede utilizar el enlace, y además este caduca tras un intervalo breve predefinido, impidiendo accesos posteriores no autorizados. Gracias a este mecanismo, si un tercero intenta acceder directamente a los buckets de S3 sin un enlace válido, la solicitud será denegada. En esencia, las URLs prefirmadas actúan como pases de acceso de un solo uso y con vigencia limitada, garantizando que los datos clínicos almacenados solo sean accesibles para quienes tengan derechos y solo durante el tiempo.


Por otro lado, VitalSanity protege la \textbf{confidencialidad de los datos en reposo} mediante cifrado robusto administrado con un \textbf{gestor de claves (KMS) personalizado}. Para todos los ficheros y datos almacenados en AWS S3, se habilita el \textbf{cifrado del lado del servidor con AWS KMS} (AWS Key Management Service), utilizando una clave de cifrado \textbf{CMK} propia  de la aplicación. Esto implica que cada objeto se almacena cifrado criptográficamente; solo a través de la clave CMK correspondiente (custodiada de forma segura) puede descifrarse su contenido. VitalSanity, al hacer uso de esta \textbf{clave CMK administrada por el cliente}, esto implica que la organización mantiene control total sobre el ciclo de vida y el uso de dichas. 


Este enfoque –recomendado por AWS para clientes que requieren un control granular de sus llaves criptográficas– permite definir políticas estrictas sobre quién o qué componentes de la aplicación pueden usar las claves para desencriptar información. En la práctica, incluso si alguien no autorizado consiguiera acceder al bucket de almacenamiento, los datos allí contenidos permanecerían ininteligibles gracias al cifrado. Adicionalmente, la gestión personalizada que ofrece KMS  da pie a poder utilizar rotación periódica de claves y registros de auditoría (vía AWS CloudTrail) de cada uso de las claves, añadiendo trazabilidad y cumplimiento de políticas de seguridad corporativas. Todo este conjunto de medidas asegura que la información médica en VitalSanity esté protegida tanto \textbf{en tránsito} (mediante conexiones HTTPS cifradas cuando se transfieren los datos) como \textbf{en reposo} (almacenada cifradamente en S3), alcanzando un nivel de seguridad acorde a la naturaleza crítica de dichos datos.







\chapter{Metodologías empleadas}



\section{Flujo de trabajo Gitflow (con Pull Requests)}
Para el desarrollo de la aplicación se ha empleado el flujo de trabajo \textbf{GitFlow} para gestionar las ramas (branches) de Git, complementado con el uso de \textbf{Pull Requests} para la integración de cambios. 

GitFlow es un modelo de ramificación ampliamente conocido que \textbf{describe el ciclo de lanzamiento del proyecto asignando roles específicos a distintas ramas} y definiendo \textbf{cuándo y cómo deben interactuar} entre sí. En este modelo se distinguen principalmente dos ramas permanentes: la rama \textbf{principal} (master o main), que almacena el historial oficial de lanzamientos estables, y la rama \textbf{de desarrollo} (develop), que es el punto de integración de las nuevas funcionalidades. 

A partir de ellas, GitFlow emplea ramas de soporte de vida corta para estructurar el trabajo: las ramas \textbf{de funcionalidad} (feature branches), creadas desde develop para desarrollar cada nueva característica o mejora; las ramas \textbf{de lanzamiento} (release branches), que se crean desde develop cuando se acumulan suficientes funcionalidades para preparar una versión pública, permitiendo pulir detalles finales (ej. corrección de bugs, documentación) sin detener el desarrollo de nuevas funciones; y las ramas \textbf{de corrección rápida} (hotfix branches), que se derivan directamente de master/main cuando es necesario corregir de urgencia un fallo en producción, aplicando el arreglo y luego fusionándolo tanto a master como a develop.

Este esquema, propuesto originalmente por Vincent Driessen, impone una disciplina en la gestión de versiones: la rama develop siempre contiene el código en estado integrador (inestable pero con las últimas novedades), mientras que master/main solo recibe código que ha pasado por un ciclo completo de pruebas y está listo para liberación. Cada fusión significativa va acompañada de un \textbf{número de versión}. Por ejemplo, al fusionar develop en master tras completar un conjunto de funcionalidades, se etiqueta una nueva versión de lanzamiento (vX.Y.Z). Esta estrategia de ramificación organizada alrededor de las publicaciones del proyecto ayuda a mantener la estabilidad en la rama principal y a aislar el desarrollo de nuevas características hasta que estén maduras.

El uso de \textbf{Pull Requests (PR)} en este flujo aporta un nivel adicional de control y revisión. Una pull request es una petición formal para incorporar los cambios de una rama en otra, usualmente acompañada de una discusión o revisión de código. Integrar pull requests dentro de GitFlow proporciona a los desarrolladores (en este caso, al desarrollador y su tutor) un espacio conveniente para \textbf{discutir los cambios de una rama antes de fusionarlos}.

Cuando una rama está lista, se crea una pull request para que su contenido sea evaluado antes de integrarse a develop; de modo similar, se utilizan pull requests al preparar una rama de lanzamiento o al aplicar un hotfix, asegurando de esta forma que dichos cambios sean revisados y aprobados antes de incorporarlos tanto a develop como a main. Las pull requests actúan de este modo como \textbf{puntos de control de calidad}: permiten revisar el código, comentar sobre él, etc. 

\subsection{Importancia de Gitflow para el desarrollo de la aplicación}
Se ha empleado GitFlow con el objetivo de \textbf{ordenar el proceso de integración de código}, evitando confusiones y manteniendo versiones estables del proyecto a lo largo del tiempo. Esta metodología ha sido de gran utilizad para asegurar que la rama principal siempre esté lista para una posible entrega o demostración, mientras el desarrollo cotidiano ocurre en ramas separadas. GitFlow facilita tener esas versiones listas sin frenar la incorporación de nuevas ideas en paralelo.

El flujo GitFlow con pull requests dota a la aplicación de un \textbf{proceso de desarrollo estructurado, colaborativo y trazable}, adecuado tanto para garantizar la robustez del resultado final como para poner en evidencia el rigor en la gestión del proyecto.

\newpage

\section{Versionado Semántico}
Como complementación a Gitflow, Se ha empleado \textbf{Versionado Semántico} (Semantic Versioning o \textbf{SemVer}) para asignar identificadores de versión a la aplicación. 

El versionado semántico es una convención ampliamente adoptada 
que define un formato \textbf{MAJOR.MINOR.PATCH} para los números de versión, donde cada componente numérico transmite información sobre la naturaleza de los cambios realizados. En concreto, la especificación SemVer 2.0.0 establece las siguientes reglas:

\begin{itemize}
  \item \textbf{MAYOR (Major)}: Se incrementa la versión mayor cuando se introducen \textbf{cambios incompatibles} con versiones anteriores (por ejemplo, modificaciones que rompen la compatibilidad de la API o eliminan funcionalidad previa).
  \item \textbf{MENOR (Minor)}: Se incrementa la versión menor cuando se añade \textbf{nueva funcionalidad de forma compatible} con la versión existente. Es decir, mejoras o características adicionales que mantienen la compatibilidad hacia atrás.
  \item \textbf{PARCHE (Patch)}: Se incrementa la versión parche cuando se realizan \textbf{correcciones de errores o cambios menores compatibles} con versiones previas. Son típicamente arreglos que no afectan la funcionalidad de forma sustancial ni rompen compatibilidad.
\end{itemize}

La esencia de esta metodología de versionado es transmitir claramente el significado y alcance de los cambios a través del número de versión. Gracias al versionado semántico también se evita el denominado \textbf{infierno de dependencia}s al establecer expectativas claras sobre la compatibilidad de la aplicación.

\subsection{Importancia del versionado semántico para el desarrollo de la aplicación}
La aplicación de versionado semántico en VitalSanity ha tenido como objetivo el de proporcionar un \textbf{esquema claro y consistente} para identificar cada entrega o iteración del software. Dado que el proyecto ha constado de diferentes fases, etiquetar cada liberación con un número de versión semántica contribuye a obtener una mejor comprensión de la \textbf{relevancia de cada versión}. 

La elección del versionado semántico como metodología se justifica por ser un \textbf{estándar ampliamente reconocido} en la industria del software (adoptado por multitud de proyectos y plataformas) y por proveer un conjunto de reglas objetivo para el versionado.  Un esquema de versionado claro facilita las discusiones sobre avances en el proyecto (por ejemplo, \textbf{en la versión 1.2.1 se incorporó la funcionalidad X}) y respalda la trazabilidad de la evolución del software. 

\newpage

\section{Planificación y seguimiento de tareas}

Para la \textbf{planificación y seguimiento} de las tareas del proyecto se ha empleado la metodología \textbf{Kanban}. Kanban es un marco de trabajo ágil que enfatiza la visualización continua del trabajo y la transparencia total del flujo de tareas. En Kanban, los elementos de trabajo (tareas, funcionalidades, etc.) se representan en tarjetas dispuestas en columnas que típicamente reflejan estados como Pendiente, En progreso y Terminado. Este tablero visual permite conocer de un vistazo el estado de cada tarea en cada momento. 

Esta funcionalidad se ha empleado tanto en un tablero Trello como en un tablero de GitHub Project asociado al repositorio de GitHub de VitalSanity.


\subsection{Importancia de Kanban para el desarrollo de la aplicación} La utilización de Kanban tiene como objetivo organizar el trabajo de forma visual y eficiente, priorizando las tareas e incrementando la transparencia del estado del proyecto.  El uso de Kanban ha servido para obtener un control estructurado pero flexible de las tareas, mejorando la gestión del tiempo y la productividad durante el desarrollo.

\newpage

\section{Reuniones periódicas de seguimiento}
Es importante destacar también las \textbf{reuniones periódicas} de seguimiento y con mi tutor de TFG Carlos.

Dichas reuniones han resultado de gran utilidad para revisar el progreso, resolver dudas, recibir orientación y asegurar que el proyecto se iba encaminando al cumplimiento de sus objetivos. Asimismo, todas estas reuniones han servido para detectar riesgos o desviaciones a tiempo y proponer correcciones o mejoras en cada sesión.

\subsection{Importancia de las reuniones periódicas para el desarrollo de la aplicación} 
La agenda de reuniones periódicas ha tenido como objetivo el de garantizar un \textbf{seguimiento continuo} del proyecto y una alineación constante con los objetivos planteados, asegurando que el desarrollo técnico estuviese respaldado por un control académico sólido.


\newpage




\chapter{Detalles de Implementación}

En este apartado se describirán los detalles más significativos e importantes a nivel de código que presenta la aplicación desarrollada



\section{Modelo Vista Controlador}

Se ha empleado una arquitectura \textbf{MVC} para desarrollar VitalSanity. En Springboot, esta arquitectura se materializa de la siguiente manera:


\begin{enumerate}
    \item \textbf{Modelo}
    \begin{itemize}
        \item Representa la \textbf{lógica de negocio} y los \textbf{datos} de la aplicación: entidades JPA, DTOs, servicios, repositorios. 
        \item Encapsula el acceso a la base de datos y las reglas de negocio, aislando el estado de la aplicación de la presentación. 
    \end{itemize}


    \item \textbf{Vista}
    \begin{itemize}
        \item Define la \textbf{interfaz de usuario}, en este caso, plantillas Thymeleaf.
        \item Se encarga únicamente de mostrar los datos que recibe del controlador y de capturar la interacción del usuario. 
    \end{itemize}


    \item \textbf{Controlador}
    \begin{itemize}
        \item Gestiona las \textbf{peticiones HTTP} entrantes (\verb|@Controller| / \verb|@RestController|). 
        \item Invoca los servicios del modelo para procesar datos, y devuelve la vista adecuada junto con el \textbf{modelo de datos} (un \verb|Model| o un objeto JSON). 
    \end{itemize}
\end{enumerate}


Las principales ventajas de aplicar el patrón \textbf{MVC} son la \textbf{reutilización, la testeabilidad, la escalabilidad y el cumplimiento del principio de Separación de responsabilidades} (Cada capa del sistema presenta una única función bien definida, de forma que nunca se mezclan la lógica de negocio, la lógica de acceso a datos y la lógica de presentación).


\section{Autenticación con certificado digital}

\subsection{Configuración del conector extra HTTPS  }

\begin{itemize}
\item La clase \verb|config/AdditionalHttpsConnectorConfig|, anotada con \\\verb|@Configuration|, se encarga de añadir un conector HTTPS adicional al servidor embebido de Tomcat en Spring Boot, configurando tanto el almacén de claves del servidor (keystore) como el almacén de confianza (truststore, el cual contiene los certificados de autoridad) para habilitar  TLS mutuo con verificación obligatoria del certificado de cliente. 
\item En primer lugar, se inyectan mediante \verb|@Value| las propiedades relativas al almacén de claves del servidor (ruta, contraseña, tipo y alias) y al almacén de confianza para validar certificados de cliente. A través del método \\\verb|servletContainer()| se crea un \verb|TomcatServletWebServerFactory| al que se agrega un conector personalizado definido en \verb|createSslConnector()|. Este conector escucha en el puerto 8059, fuerza el esquema \verb|https| y activa SSL en el protocolo \verb|Http11NioProtocol|. 
\item A continuación, se construye un \verb|SSLHostConfig| que impone la verificación de certificado de cliente (\verb|required|),  incorpora una lista de revocación de certificados (CRL), y se asocia el truststore para validar las cadenas de certificado entrantes. 
\item Despúes, se crea un \verb|SSLHostConfigCertificate| de tipo RSA, que carga el keystore del servidor con sus credenciales y alias, y se añade a la configuración SSL del conector. De este modo, la aplicación autentica de forma mutua tanto al cliente como al servidor antes de procesar cualquier petición relacionada con la autenticación por certificado digital. 
\end{itemize}

\subsection{Filtro de preautenticación X.509}

\begin{itemize}
    \item La clase \verb|SecurityConfig| configura, con la máxima prioridad, una cadena de filtros dedicada exclusivamente a la autenticación mediante certificado digital en el endpoint \verb|/login/certificate|. 
    \item En su método \verb|certificateFilterChain|, se crea un extractor de sujeto X.509 (\verb|SubjectDnX509PrincipalExtractor|) que extrae el NIF del DN del certificado mediante una expresión regular, y se instancia un \\\verb|X509AuthenticationFilter| al que se le asigna dicho extractor, un manejador de éxito (\verb|CertificateAuthenticationSuccessHandler|) y se indica que, si la autenticación por certificado falla, continúe la cadena de filtros sin interrumpir la petición. 
    \item Para validar las credenciales preautenticadas del certificado se utiliza un \\\verb|PreAuthenticatedAuthenticationProvider| conectado a un \\\verb|UserDetailsService| personalizado (CertificateUserDetailsService), envolviéndolo en un \verb|ProviderManager| que actúa como \\\verb|AuthenticationManager| del filtro. 
    \item Finalmente, el filtro se añade al \verb|HttpSecurity| limitado únicamente al patrón \verb|/login/certificate|, se establece una política de creación de sesión “si es necesario” y, dado que en entorno de desarrollo he empleado un certificado SSL autogenerado (el cual impide al navegador abrir el selector de certificados bajo protección CSRF), se deshabilita la protección CSRF para este único endpoint, permitiendo así la extracción y validación del certificado sin conflictos, mientras que todas las peticiones quedan autorizadas tras este filtro.
    \item Cabe destacar que en producción no sería necesario desactivar la protección CSRF para ese endpoint puesto que en producción se estaría utilizando un certificado SSL de confianza.

\end{itemize}

\subsection{Servicio de detalles de usuario  }

\begin{itemize}
    \item La clase \verb|UserDetailsService | se encarga de buscar en la base de datos un usuario cuyo NIF/NIE coincida con el extraído del certificado digital correspondiente. En el caso de que dicho usuario exista, crea un \verb|UserDetails| con rol \verb|ROLE_USER|; en caso contrario, se lanza la excepción \\\verb|UsernameNotFoundException|.
    \item El \verb|UserDetails| es necesario para que \verb|Spring Security| pueda completar el paso de pre-autenticación X.509 y poblar el principal de la sesión de seguridad.
\end{itemize}

\subsection{Manejador de éxito de autenticación  }

La clase \verb|config/CertificateAuthenticationSuccessHandler| se encarga de obtener el NIF/NIE extraído y de consultar el repositorio de usuarios. Si no hay coincidencias, redirige a \verb|/login?error=usuario_no_encontrado|. Si hay coincidencia, entonces se termina de autenticar al usuario y se completa de forma exitosa el proceso de autenticación.

\subsection{Consideraciones de seguridad}

Esta implementación permite: \textbf{máxima confianza}, puesto que la validación a nivel TLS impide el paso de clientes no autorizados; \textbf{Integridad del flujo }, puesto que el filtro X.509 y el handler separan claramente la extracción de identidad, la validación en base de datos y la navegación posterior; \textbf{extensibilidad}, gracias a que en \textbf{Spring Security} es sencillo añadir nuevos roles, reglas de autorización o múltiples esquemas de autenticación.

\newpage

\section{Firma y cofirma de los documentos PDF}

\subsection{Generación del PDF a partir de iText}
La clase \verb|service/autofirma/GenerarPdf.java| se encarga de generar el PDF que debe ser \textbf{firmado} o \textbf{cofirmado} a partir de los datos recopilados de un formulario. Los datos del formularios son recogidos y se crea un \textbf{PDF} con un formato acorde y atractivo y en el que incluye toda la información relevante en materia de protección de datos, aludiendo en todo momento tanto a la \textbf{LOPDGDD } y al \textbf{RGPD}.

\subsection{autoscript.js}
El fichero \verb|autoscript.js| representa la “biblioteca de despliegue” del Cliente @firma: al cargarlo dentro del \verb|<head>| de un HTML, se logra aportar un objeto global AutoScript que expone toda la API JavaScript necesaria para invocar todas operaciones de firma disponibles(firma simple, cofirma, contrafirma, firma de lotes, selección de certificado, etc.), encapsulando de este modo los detalles de comunicación con la aplicación nativa. Este fichero forma parte de la API oficial de @firma y puede obtenerse directamente en el repositorio de GitHub de @firma


\newpage

\subsection{signer-invoke.js}
El fichero \verb|signer-invoke.js| orquesta de manera genérica el flujo de firma y co-firma de documentos en la interfaz web. 

\begin{figure}[H]
\centering
\includegraphics[width=0.885\textwidth, height=1\textheight, keepaspectratio]{img/carga-de-auto-script-y-de-signer-invoke.png}
\caption{Carga de autoscript.js y de signer-invoke.js}
\label{carga-de-auto-script-y-de-signer-invoke:vv}
\end{figure}

\begin{figure}[H]
\centering
\includegraphics[width=0.885\textwidth, height=1\textheight, keepaspectratio]{img/carga-app-autofirma.png}
\caption{Carga de la app de AutoFirma/Cliente móvil @firma}
\label{carga-app-autofirma:vv}
\end{figure}


Al pulsar sobre el botón correspondiente a “Firmar”, se recogen los datos del formulario, se llama al método de controlador correspondiente para que se devuelva un PDF en Base64 y se invoca a \verb|AutoScript.sign(...)| para que se abra AutoFirma (o su versión para móvil), se abra el selector de certificados y el usuario pueda firmar el fichero correspondiente. 

\newpage

El método \textit{AutoScript.sign()} recibe los siguientes parámetros en el siguiente orden:

\begin{itemize}
    \item Cadena con los datos del PDF a firmar, codificada en Base64. 
    \item El algoritmo criptográfico con el que se genera la firma. En este caso, \textbf{SHA-512} para el hash y \textbf{RSA} para la \textbf{firma asimétrica} (\textbf{SHA512withRSA}).
    \item El formato de la firma. '\textbf{PAdES}' indica que se produce una \textbf{firma embebid}a en PDF conforme al perfil \textbf{PAdES}. \textbf{PAdES} es el \textbf{perfil} de firma electrónica avanzada para documentos \textbf{PDF} que garantiza la \textbf{integridad}, \textbf{autenticidad}, \textbf{validez} y \textbf{no repudio} a largo plazo de la \textbf{firma incrustada} conforme a la norma \textbf{ETSI EN 319 142}.
    \item Un objeto para pasar parámetros específicos al proceso de firma (p. ej. \textbf{políticas}, \textbf{visibilidad de la firma}, \textbf{posición}, etc.). Con \textbf{null} se usan los valores por defecto. 
    \item Función que se invoca cuando la firma termina correctamente (\textbf{callback de éxito}). Recibe como argumentos: La \textbf{firma resultante} en \textbf{Base64}, El \textbf{certificado} del firmante en \textbf{Base64}, Un objeto \textbf{extraInfo} (por ejemplo, nombre original del fichero).
    \item Función que se invoca si ocurre \textbf{algún fallo} durante la firma (\textbf{callback de error}). Recibe como argumentos: \textbf{un código o texto} que identifica el tipo de error y un \textbf{mensaje descriptivo} del error.
\end{itemize}

\vspace{1em}

\begin{figure}[H]
\centering
\includegraphics[width=0.885\textwidth, height=1\textheight, keepaspectratio]{img/autoscript-sign.png}
\caption{AutoScript.sign}
\label{autoscript-sign:vv}
\end{figure}

\vspace{1em}

\begin{figure}[H]
\centering
\includegraphics[width=0.885\textwidth, height=1\textheight, keepaspectratio]{img/selector-de-certificados.png}
\caption{Selector de certificados de AutoFirma}
\label{selector-de-certificados:vv}
\end{figure}

Durante el tiempo en el que se está completando  la firma se muestra por pantalla un \textbf{overlay} con el mensaje \textbf{'Procesando... por favor, espere'} para indicarle al usuario que se está procesando la operación de firma.

\begin{figure}[H]
\centering
\includegraphics[width=0.885\textwidth, height=1\textheight, keepaspectratio]{img/overlay-autofirma.png}
\caption{Overlay para el procesamiento de la firma}
\label{overlay-autofirma:vv}
\end{figure}

Tras recibir la firma en Base64, se envía de nuevo al servidor el documento firmado: Por una parte, en la base de datos se almacenan los siguientes metadatos asociados al documento: nombre, uuid (aleatorio), s3Key (aws), el tipo dearchivo, el tamaño y la fecha de creación.
Por otra parte, el documento completo se sube a aws a partir de la S3 key correspondiente. Se utiliza el uuid para nombrar al documento dentro del bucket para así evitar que se revele metainforación asociada al nombre real del documento.  

\newpage

Una vez que se ha almacenado los metadatos del fichero y se ha subido a aws, se le muestra al usuario un enlace para poder descargar el PDF recién firmado. Dicho enlace contiene una URL prefirmada para acceder de forma privada al contenido del bucket (todo lo asociado a AWS se explica más adelante con más detalle).

\vspace{1em}

\begin{figure}[H]
\centering
\includegraphics[width=0.885\textwidth, height=1\textheight, keepaspectratio]{img/mensaje-descarga-firma.png}
\caption{Mensaje con el enlace de descarga para la firma}
\label{mensaje-descarga-firma:vv}
\end{figure}

Se puede verificar que la firma del PDF es válida abriendo el propio PDF con \textbf{Adobe Acrobat Reader}

\vspace{1em}

\begin{figure}[H]
\centering
\includegraphics[width=0.885\textwidth, height=1\textheight, keepaspectratio]{img/pdf-firmado.png}
\caption{PDF firmado}
\label{mensaje-descarga-firma:vv}
\end{figure}

\newpage

El proceso de cofirma es análogo al proceso ya descito de firma normal. Lo único que cambia es la llamada al fichero AutoScript.js, que ahora pasa a ser \\\verb|AutoScript.cosign(...)|  (se cambia la función \textbf{sign(...)} por \textbf{cosign(...)}).



De igual modo, cuando el paciente cofirma, se recupera del servidor el PDF ya firmado, se invoca a \verb|AutoScript.cosign(...)| para añadir la firma sin sobreescribir la firma ya establecida del profesional médico y sube el resultado para posteriormente mostrar el enlace de descarga del \textbf{PDF cofirmado} . 

\begin{figure}[H]
\centering
\includegraphics[width=0.885\textwidth, height=1\textheight, keepaspectratio]{img/autoscript-cosign.png}
\caption{AutoScript.cosign}
\label{autoscript-cosign:vv}
\end{figure}

\begin{figure}[H]
\centering
\includegraphics[width=0.885\textwidth, height=0.4\textheight, keepaspectratio]{img/pdf-cofirmado.png}
\caption{PDF cofirmado (con dos firmas)}
\label{pdf-cofirmado:vv}
\end{figure}

Este flujo descrito de \textbf{AutoFirma} se repite de forma análoga para todas las siguientes funcionalidades:

\begin{itemize}
    \item Firma de la autorización de acceso por parte del profesional médico.
    \item Cofirma de la autorización de acceso por parte del paciente.
    \item     Firma de un nuevo informe subido por un profesional médico.
    \item Firma de un nuevo informe editado por un profesional médico
\end{itemize}
Cabe destacar que cualquiera de estas acciones puede ser realizada tanto con \textbf{AutoFirma} como con \textbf{Cliente móvil @firma }.


\newpage

\subsection{\textbf{Cliente móvil @firma } }


Para conseguir que las funcionalidades de firma y cofirma sigan funcionando en dispositivos móviles, ha sido necesario realizar una serie de cambios \textbf{importantes} y \textbf{no triviales}.

En primer lugar, se ha sustituido el canal de comunicación por sockets (el modo por defecto de AutoFirma) por el mecanismo de "servidor intermedio".

Como se explica en el \textbf{Manual Integrador de AutoFirma}, en un ordenador el JavaScript \textit{autoscript.js} puede abrir un \textit{socket} local  y comunicarse directamente con la aplicación nativa \textbf{AutoFirma} que está escuchando en ese puerto. Este canal bidireccional es rápido y no atraviesa la red, por lo que en en un ordenador resulta la opción más conveniente. 

No obstante, en dispositivos móviles, esta técnica deja de funcionar debido a dos motivos principales:

\begin{itemize}
    \item \textbf{Restricciones de los navegadores y del propio sistema operativo:} Ni Android ni iOS permiten que una página web abra un puerto de escucha local ni que una app nativa exponga un \textit{socket} accesible desde el navegador. El único puente soportado es lanzar la app nativa mediante un esquema de URL (\verb|afirma://…|) y, después, volver al navegador a través de una navegación HTTP/S. 
    \item \textbf{Carencia de la JVM y de la librería de sockets en las versiones móviles del cliente :} Los clientes móviles de @firma no incluyen un servicio que permanezca escuchando; se abren “puntualmente” cuando el navegador invoca el esquema \textit{afirma://}. 
\end{itemize}

Por todo esto, cuando el usuario firma desde \textbf{Android} o \textbf{iOS}, el flujo debe cambiar al mecanismo llamado “\textbf{servidor intermedio}”: 


\begin{itemize}
    \item El JavaScript envía los datos a firmar al \textbf{StorageService} del servidor.
    \item La app móvil recupera esos datos, genera la firma y sube el resultado al mismo servidor.
    \item Finalmente, la página web los recoge a través del \textbf{RetrieveService}.
\end{itemize}


El propio \textbf{manual integrador} lo resume de esta manera en la \textbf{sección 5.3.1}:

“\textit{Los servicios de almacenamiento y recuperación en servidor son necesarios … Cuando el usuario utilice un dispositivo móvil y los clientes móviles Android o iOS}.” 


Habiendo explicado todo lo anterior, para conseguir establecer el mecanismo de \textbf{servidor intermedio} para las operaciones de firma cuando se esté empleando un dispositivo móvil, hay que realizar los siguientes cambios:

\begin{itemize}
    \item Se agrega en \textit{signer-invoke.js} el siguiente fragmento de código encargado de forzar a utilizar el modo de \textbf{servidor intermedio} cuando se está utilizando un dispositivo móvil. Además, este fragmento de código también se encarga de configurar las URLs de los servicios necesarios: \textbf{StorageService} para almacenar los datos que se van a firmar y \textbf{RetrieveService } para recuperar los datos una vez firmados.
\end{itemize}


\begin{figure}[H]
\centering
\noindent\makebox[\textwidth]{\includegraphics[width=0.625\paperwidth]{img/autofirma-movil.jpg}}
\caption{Se fuerza el uso del modo "servidor intermedio" para móviles} \label{fig:autofirma-movil}
\end{figure}

\begin{itemize}
    \item Se despliega un Tomcat externo protegido con TLS el cual se encarga de desplegar los \textbf{WAR} \textit{afirma-signature-storage.war } y \textit{afirma-signature-retriever.war } que implementan los servlets \textit{StorageService} y \textit{RetrieveService} responsables de almacenar y devolver temporalmente los datos firmado.
    \item Para garantizar que las peticiones se cursen siempre dentro del mismo dominio de la aplicación \textbf{VitalSanity} –condición necesaria para evitar bloqueos de tipo XSS/CORS– se ha colocado por delante un \textit{\textbf{Nginx}} para actuar como un \textit{\textbf{proxy inverso}} que expone el puerto 443 y redirige selectivamente las rutas \textit{/vital-sanity/afirma-signature-storage/}, \textit{/…-retriever/} y \textit{/…-triphase-signer/} hacia \textbf{Tomcat}, reenviando el resto del tráfico de la aplicación Spring Boot al puerto 8058; 
    \item Este \textit{\textbf{reverse proxy}} unifica URL y política de seguridad, y añade la directiva CSP que permite el esquema \textbf{\textit{afirma://*}}, requisito necesario de los \textbf{navegadores móviles }.
\end{itemize}

Con todo esto, se consigue que en la aplicación se pueda firmar y cofirmar documentos tanto desde un ordenador (utilizando \textbf{AutoFirma}) como desde un dispositivo móvil (utilizando \textbf{\textbf{Cliente móvil @firma }}).

\vspace{1em}

\begin{figure}[H]
\centering
\includegraphics[width=0.885\textwidth, height=0.5\textheight, keepaspectratio]{img/selector-certificados-movil.png}
\caption{Selector de Certificados en el móvil}
\label{selector-certificados-movil:vv}
\end{figure}

\newpage

\section{Configuración de AWS}

\subsection{Objetos que se almacenan en el bucket}
En el bucket de AWS asociado a \textbf{VitalSanity} se almacenan los siguientes documentos asociados con el flujo principal de la aplicación:
\begin{itemize}
    \item Autorizaciones firmadas (en \textit{autorizaciones/firmadas})
    \item     Autorizaciones cofirmadas (en \textit{autorizaciones/cofirmadas})
    \item Informes firmados (en \textit{informes/firmados})
    \item Documentos médicos asociados a los informes (en \textit{informes/documentos})
\end{itemize}

\subsection{Dependencias agregadas}

Se ha agregado en el \textbf{POM} la dependencia \textit{software.amazon.awssdk:s3 } la cual habilita todo el sistema de gestión de archivos en la nube mediante Amazon S3. 

\begin{figure}[H]
\centering
\noindent\makebox[\textwidth]{\includegraphics[width=0.625\paperwidth]{img/aws-dependencia-pom.jpg}}
\caption{Dependencia de AWS para Spring Boot} \label{fig:aws-dependencia-pom}
\end{figure}

\subsection{Gestión de credenciales AWS }

Para gestionar las credenciales de AWS de forma segura, se ha ejecutado el comando \textbf{aws configure} (la aplicación se ha desarrollado en Windows). Este comando crea un directorio oculto \textbf{.aws} en el perfil de usuario con dos archivos principales:

\begin{itemize}
    \item \textbf{credentials}: almacena el par \textbf{Access Key ID} y \textbf{Secret Access Key}.
    \item \textbf{config}: define la región por defecto (region = \textbf{eu-south-2}) y formato de salida.
\end{itemize}

Gracias a esto, no se incrustan las credenciales en el código fuente ni en los ficheros de configuración de la aplicación, reduciendo el riesgo de exposición. 


En el código, el SDK de AWS emplea el proveedor por defecto (\textit{DefaultCredentialsProvider}), que busca automáticamente las credenciales en este archivo oculto, o en variables de entorno.

\begin{figure}[H]
\centering
\noindent\makebox[\textwidth]{\includegraphics[width=0.625\paperwidth]{img/aws-default-credential-providers.jpg}}
\caption{Proveedor de credenciales en el código} \label{fig:aws-default-credential-providers}
\end{figure}

\begin{figure}[H]
\centering
\noindent\makebox[\textwidth]{\includegraphics[width=0.65\paperwidth]{img/vv.png}}
\caption{Proveedor de credenciales en el código} \label{fig:vv}
\end{figure}

Cabe destacar que, como VitalSanity es una aplicación dentro del ámbito nacional español, se ha cambiado manualmente la región por defecto del bucket de AWS de forma que ahora la región correspondiente sea \textbf{eu-south-2} (Madrid, España). 

Este cambio de la región por defecto es beneficioso porque garantiza que los datos personales almacenados permanezcan físicamente dentro del territorio español, facilitando así el cumplimiento del \textbf{RGPD} y de la \textbf{LOPDGDD}  al evitar transferencias internacionales de datos que exigirían requisitos legales adicionales. Además, mejora la latencia para usuarios nacionales y refuerza la confianza en la gestión segura de información sensible. 

\subsection{Subida de archivos}

Se utilizan dos métodos principales de la clase \textit{S3VitalSanityService} para la subida de archivos: uno sube un archivo de tipo \textbf{MultipartFile } y otro que sube un archivo de tipo \textit{byte[]}.

\begin{figure}[H]
\centering
\noindent\makebox[\textwidth]{\includegraphics[width=0.625\paperwidth]{img/aws-subirFicheroo-multipaart.jpg}}
\caption{Subir fichero de tipo MultipartFile} \label{aws-subirFicheroo-multipaart:vv}
\end{figure}

\begin{figure}[H]
\centering
\noindent\makebox[\textwidth]{\includegraphics[width=0.625\paperwidth]{img/aws-subirFichero-Bytes.jpg}}
\caption{Subir fichero de tipo byte[]} \label{aws-subirFichero-Bytes.jpg:vv}
\end{figure}

Los ficheros en el bucket no se almacenan con su nombre real, sino que se almacenan con un UUID aleatorio para así ocultar cualquier posible metainformación existente en el nombre real que pudiese revlar cualquier información (aunque sea mínima) a un atacante.

 Se especifica \textit{ServerSideEncryption.AWS-KMS}, delegando la gestión de claves al bucket (SSE-KMS) mediante una clave \textbf{CMK} personalizada (esto se explica más adelante con más detalle)

 \subsection{Generación de URLs pre-firmadas}

 Cada vez que se trata de descargar cualquier docuemtno subido al bucket de aws, se genera una URL prefirmada. Esto permite descargar objetos de S3 sin exponer públicamente el bucket ni requerir credenciales \textbf{AWS}. De esta manera, la URL pública de cualquier objeto dentro del bucket permanece privada, de forma que incluso si un atacante lograse acceso a una de estas URLs y la copiase en el navegador, aún así no podría descargar el documento asociado ya que estaría protegido. Únicamente se puede acceder a los objetos del bucket  a partir de las \textbf{URLs prefirmadas}.


\begin{figure}[H]
\centering
\noindent\makebox[\textwidth]{\includegraphics[width=0.625\paperwidth]{img/aws-url-prefirmadas.jpg}}
\caption{Método para generar una URL prefirmadas} \label{aws-url-prefirmadas:vv}
\end{figure}

\begin{figure}[H]
\centering
\noindent\makebox[\textwidth]{\includegraphics[width=0.625\paperwidth]{img/ejemplo-bucket-inaccesible.jpg}}
\caption{Error cuando se trata de acceder directamente a la URL pública de un documento dentro del bucket de aws} \label{ejemplo-bucket-inaccesible:vv}
\end{figure}


Por otra parte, este otro método se utiliza para obtener los bytes de un fichero a partir de su S3Key. Este método es empelado para recuperar la autorización firmada de aws en forma de array de bytes para que el paciente pueda cofirmar dicha autorización.
 \begin{figure}[H]
\centering
\noindent\makebox[\textwidth]{\includegraphics[width=0.625\paperwidth]{img/obtener-bytes-fichero.jpg}}
\caption{Método usado para obtener los bytes de un fichero a partir de su S3Key} \label{obtener-bytes-fichero:vv}
\end{figure}


\newpage

\subsection{Subida de múltiples ficheros a AWS}



Para la subida de múltiples ficheros en AWS se emplea un método de controlador el cual recibe un array de \textbf{MultipartFile}. Por cada fichero se obtiene su nombre, tipo y tamaño, crea en la base de datos un registro (DocumentoData) asociado al informe; se extrae la clave S3 generada (\textbf{s3Key}) y, mediante los métodos que ya hemos visto del servicio \textbf{s3VitalSanityService}, se sube el archivo al bucket de AWS.

Para que todo esto funcione correctamente, en el HTML se agrega un formulario con \textit{enctype="multipart/form-data"} el cual permite el envío de varios ficheros.
Asimismo, se agrega un atributo \textit{accept} para restringir los tipos de los documentos que se pueden subir a \textbf{pdf, jpg, jpeg y png} .

Este método se utiliza para la subida de documentos asociados a un informe médico.

 \begin{figure}[H]
\centering
\noindent\makebox[\textwidth]{\includegraphics[width=0.625 \paperwidth]{img/aws-subir-multiples-documentos.jpg}}
\caption{Método usado para subir múltiples ficheros a AWS} \label{aws-subir-multiples-documentos:vv}
\end{figure}

\newpage


\section{Configuración específica de AWS}

\subsection{Principio de Mínimos Privilegios}

Uno de los principales objetivos de la configuración del \textbf{bucket} de \textbf{AWS} ha sido el de cumplir con el \textbf{Principio de Mínimos Privilegios} (Conocido en inglés como \textbf{\textit{the principle of least privilege }} o \textbf{\textit{PoLP}}).

Este principio consiste en otorgar a cada identidad (usuario, rol o servicio) únicamente los permisos estrictamente necesarios para realizar sus tareas, reduciendo así el riesgo de acceso no autorizado .

\subsection{Privacidad del bucket}
Otro de los principales objetivos ha sido el de proteger las URLs públicas de cada uno de los objetos del bucket de forma que dichos objetos sean accesibles mediante la generación de \textbf{URLs prefirmadas con tiempos cortos de expiración} (procedimiento ya descrito en la sección de implementación).

Para ello, se ha activado dentro del bucket la opción de \textbf{\textit{Bloquear \textit{todo} el acceso público} }. De esta forma, nadie podrá acceder directamente a un objeto del bucket a través de su \textbf{URL pública}. Para acceder a estos objetos se requiere siempre de una \textbf{URL prefirmada}.

\begin{figure}[H]
\centering
\includegraphics[width=0.885\textwidth, height=1\textheight, keepaspectratio]{img/bucket-privado.jpg}
\caption{Bloquear todo el acceso público al bucket}
\label{bucket-privado:vv}
\end{figure}

\begin{figure}[H]
\centering
\includegraphics[width=0.885\textwidth, height=1\textheight, keepaspectratio]{img/ejemplo-bucket-inaccesible.jpg}
\caption{Error cuando se trata de acceder directamente a la URL pública de un documento dentro del bucket de aws}
\label{ejemplo-bucket-inaccesible.jpg:vv}
\end{figure}


\subsection{IAM}

\textbf{IAM} \textbf{(Identity and Access Management) }es el servicio de \textbf{AWS} que  permite gestionar de forma segura el acceso a los recursos de una cuenta de \textbf{AWS}. En el caso de \textbf{VitalSanity}, \textbf{IAM} se ha utilizado para configurar el acceso a los documentos del bucket. 

 \begin{figure}[H]
\centering
\noindent\makebox[\textwidth]{\includegraphics[width=5cm,height=3cm,keepaspectratio]{img/IAM-logo.jpg}}
\caption{Icono de AWS IAM} \label{IAM-logo:vv}
\end{figure}

\begin{itemize}
    \item Por un lado, se ha creado un grupo de usuarios IAM. En AWS, un \textbf{grupo} es una colección de usuarios IAM; permite asignar permisos de forma centralizada a todos sus miembros en lugar de hacerlo usuario por usuario.\\Para la aplicación se ha creado un grupo de usuarios denominado \textbf{Desarrolladores} con permisos de lectura/escritura en buckets de desarrollo y otro grupo denominado \textbf{Administradores} el cual tendría acceso a los buckets en producción. \\Los grupos de usuarios permiten aplicar el \textbf{principio de mínimos privilegios} y segregar accesos para que los desarrolladores solo manejen entornos de pruebas mientras los administradores gestionan producción, reduciendo así riesgos y simplificando la administración de permisos y la futura puesta en producción.
    \item Por otra parte, se ha creado un usuario IAM dentro de cada uno de los dos grupos de usuario anteriormente mencionados. Los usuarios IAM representan a entidades a las que se les conceden permisos específicos para poder ejecutar determonadas acciones.
    \item Por último a cada uno de estos usuarios se les ha asignado políticas especifícas para concederles permisos concretos. Las políticas son documentos \textbf{JSON} de permisos incrustados directamente en la definición de un usuario concreto. Las políticas no son reutilizables por otras entidades. A cada uno de los usuarios se les ha asignado una política creada manualmente asegurando en todo momento que se cumpliese el \textbf{Principio de Mínimos Privilegios}.
\end{itemize}

\begin{figure}[H]
\centering
\includegraphics[width=0.885\textwidth, height=1\textheight, keepaspectratio]{img/aws-politica-personalizada.jpg}
\caption{Política Personalizada de AWS}
\label{aws-politica-personalizada:vv}
\end{figure}

\begin{figure}[H]
\centering
\includegraphics[width=0.885\textwidth, height=1\textheight, keepaspectratio]{img/aws-json-politica-personalizada.jpg}
\caption{JSON de Política Personalizada de AWS}
\label{aws-json-politica-personalizada:vv}
\end{figure}
\newpage

\subsection{Claves personalizadas CMKs}
Las claves \textbf{CMKs} (Customer-Managed Keys) son claves maestras creadas y administradas por el propietario del bucket. Estas claves permiten una gran personalización gracias a su manejo en AWS Key Management Service: permiten cifrar y descifrar datos con control detallado sobre rotación, acceso y auditoría. 

\begin{figure}[H]
\centering
\includegraphics[width=0.25\textwidth, height=0.25\textheight, keepaspectratio]{img/AWS-KMS-Logo.jpg}
\caption{Icono de AWS KMS}
\label{AWS-KMS-Logo.jpg:vv}
\end{figure}
Al establecer en el bucket estas claves personalizadas \textbf{CMK}, se logra conseguir un mayor control y personalización tanto de las autorizaciones como de los documentos e informes médicos, lo que permite obtener una seguridad mucho más robusta.

\begin{figure}[H]
\centering
\includegraphics[width=0.885\textwidth, height=1\textheight, keepaspectratio]{img/clave-cmk-personalizada.jpg}
\caption{Clave CMK personalizada}
\label{clave-cmk-personalizada:vv}
\end{figure}

\newpage

\subsection{Región del bucket}
Como ya se ha mencionado con anterioridad, se ha cambiado la región por defecto del bucket para que la región del bucket sea \textbf{eu-south-2 } (Madrid, España, dado que la VitalSanity se sitúa dentro del ámbito nacional español). 

Como ya se había comentado, con esto se consigue garantizar que los datos personales almacenados permanezcan físicamente dentro del territorio español, facilitando así el cumplimiento del \textbf{RGPD} y de la \textbf{LOPDGDD}  al evitar transferencias internacionales de datos que exigirían requisitos legales adicionales. Además, también se mejora la latencia para usuarios nacionales a la par que se refuerza la confianza en la gestión segura de información sensible. 

\vspace{1em}

\begin{figure}[H]
\centering
\includegraphics[width=0.885\textwidth, height=1\textheight, keepaspectratio]{img/aws-region-y-arn-bucket.jpg}
\caption{Región y ARN del bucket}
\label{aws-region-y-arn-bucket:vv}
\end{figure}


\section{Base de datos dockerizada}

Durante todo el desarrollo de la aplicación se ha empleado una base de datos \textbf{dockerizada} de \textbf{PostgreSQL}. Esta se articula en primer lugar mediante el despliegue de un contenedor Docker dedicado, configurado con variables de entorno \textit{(\textit{POSTGRES\_USER, POSTGRES\_PASSWORD, POSTGRES\_DB})} y mapeo de puertos \textbf{(-p 5058:5432)}, lo cual garantiza un entorno aislado, reproducible y alineado con las dependencias de producción. 

Para poder utilizar esta base de datos \textbf{dockerizada}, se ha creado un perfil de Springboot denominado \textit{"postgres"}, el cual se activa mediante \\\textit{spring.profiles.active=postgres} en el fichero de configuración \textit{application.properties}.

Para el manejo del perfil de \textbf{Postgres} se ha creado un fichero llamado \textit{application-postgres.properties}.

Todo esto permite conmutar \textbf{dinámicamente} la configuración de la capa de \textbf{persistencia}: se redefinen \textbf{la URL de conexión}, las credenciales de acceso y el dialecto de \textbf{Hibernate} (\textbf{PostgreSQLDialect}), asegurando que el ciclo de vida de la base de datos concuerde con el esquema y las prácticas de producción.

Esta separación de perfiles no solo favorece la claridad y mantenibilidad del proyecto (pues aísla la configuración de \textbf{desarrollo (H2 en memoria) de la de integración (PostgreSQL)}), sino que también refuerza la \textbf{portabilidad} y la \textbf{escalabilidad}, al permitir que equipos multidisciplinares reproduzcan con facilidad el entorno real sin \textbf{“ruido”} de \textbf{configuración local} (evitando de esta manera problemas clásicos del estilo "\textbf{en \textbf{mi ordenador} sí que funcionaba}").

Asimismo, en el archivo de configuración \textit{application.properties} se establece la propiedad \textit{spring.jpa.hibernate.ddl-auto=update} , gracias a la cual se le indica a \textbf{Hibernate} que, al arrancar la aplicación, compare las \textbf{entidades JPA} con el esquema de la base de datos y aplique automáticamente las modificaciones necesarias para mantenerlos sincronizados. 

\begin{figure}[H]
\centering
\includegraphics[width=0.885\textwidth, height=1\textheight, keepaspectratio]{img/application-postgres-properties.png}
\caption{Archivo de configuración \textit{application-postgres.properties}}
\label{application-postgres-properties:vv}
\end{figure}

Por último, mencionar que todo esto se ha replicado de forma análoga para la ejecución de tests (se ha creado tanto un fichero \textit{application.properties.java} como un fichero \textit{application-postgres.properties.java}  independientes) para poder ejecutar los tests de forma \textbf{aislada} y sobre una \textbf{base de datos separada} de la \textbf{base de datos de desarrollo}. Mencionar que, aunque en la aplicación solo se haya incluido un único test de prueba, esta medida sería de gran utilidad si en el futuro se plantease agregar un elevado número de tests para la aplicación. 

\begin{figure}[H]
\centering
\includegraphics[width=0.885\textwidth, height=1\textheight, keepaspectratio]{img/application-postgres-tests-properties.png}
\caption{Archivo de configuración \textit{application-postgres.properties}}
\label{application-postgres-tests-properties:vv}
\end{figure}


\section{Docker Compose}

\textbf{Docker Compose} actúa como un orquestador que permite levantar todo el proyecto mediante un único y sencillo comando:  \textbf{docker-compse up}. Gracias a esto se dota a la aplicación de \textbf{portabilidad} y evitan problemas de configuración \textbf{local} (evitando de esta manera problemas clásicos del estilo \textit{'en mi ordenador sí que funcionaba'}).

Cuando se invoca el comando \textbf{docker-compse up}, \textbf{Compose} primero procesa el servicio \textbf{app}, el cual utiliza un \textbf{Dockerfile} de dos etapas: en la fase \textbf{builder}, un contenedor \textbf{Maven} (imagen maven:3.9.9-eclipse-temurin-21) se sitúa en \textbf{/app}, copia el \textbf{pom.xml }y \textbf{el código fuente}, y ejecuta \textbf{mvn clean package -DskipTests} para generar el \textbf{JAR final}; en la fase runtime, la imagen \textbf{eclipse-temurin:21-jdk-alpine} crea un usuario no privilegiado (\textbf{appuser}), copia el artefacto \textit{/app/target/*.jar }a \textit{/app/app.jar} y expone el puerto \textbf{8058}.

Mediante CMD \textit{["java", "-jar", "app.jar", "--spring.profiles.active=docker"]}, \textbf{Compose} arranca la aplicación con el perfil “\textbf{docker}”. 

 La configuración del perfil (“application-docker.properties”) inyecta variables de entorno (\texttt{POSTGRES\_HOST=db, DB\_USER=vital, DB\_PASSWD=vital})
 que redefinen la conexión \textbf{JDBC} a PostgreSQL. A su vez, el servicio \textit{db} levanta la imagen oficial \textbf{postgres:15}, expone internamente el puerto 5432 (mapeándolo al 5058 del \textbf{host}), establece \textbf{credenciales}, y utiliza un \textbf{volumen} \textbf{Docker (db-data)} para \textbf{persistir} los datos en \textit{/var/lib/postgresql/data.}

 Establecer un \textbf{volumen de docker} es de \textbf{vital importancia} ya que garantiza  la persistencia y aislamiento de los datos más allá del ciclo de vida del contenedor, facilitando además su respaldo y migración.

 Por otra parte, \textbf{Compose} monta un \textbf{script de inicialización SQL} en \textit{/docker-entrypoint-initdb.d/}, lo que permite poblar \textbf{la bd con datos de desarrollo} en cuanto el contenedor arranca. Antes de ejecutar el script, \textbf{Compose} comprueba si la base de datos ya estaba poblada de antes.

 Ambos servicios se unen a la red personalizada \textit{app\_network} \textbf{(driver bridge)}, garantizando \textbf{aislamiento de red} y \textbf{comunicación directa por nombre de servicio}, mientras que la directiva \textit{depends\_on} asegura el siguiente orden de arranque: \textbf{primero db, luego app}.

 \newpage

 Gracias al establecimiento de \textbf{Docker Compose} se logra \textbf{reproducibilidad absoluta del entorno}, \textbf{versionado de la infraestructura junto al código}, \textbf{consistencia entre equipos y entornos}, \textbf{escalabilidad}, \textbf{aislamiento de dependencias} y \textbf{reducción drástica de la complejidad en la instalación manual de bases de datos}, \textbf{variables de entorno y configuraciones específicas}.

 Basta con ejecutar el comando \textbf{docker-compose down} para desmontar todo sin dejar residuos en el host, lo que facilita las pruebas, el despliegue continuo y el paso de desarrollo a producción con los mínimos cambios posibles.

 Sin duda, \textbf{Docker Compose} es una de las herramientas que más dolores de cabeza nos ahorra a cualquier desarrollador.

\begin{figure}[H]
\centering
\includegraphics[width=0.885\textwidth, height=1\textheight, keepaspectratio]{img/application-docker-properties.png}
\caption{Archivo de configuración \textit{application-docker.properties}}
\label{application-docker-properties.png:vv}
\end{figure}

\newpage

\section{Mailtrap}

Dentro del desarrollo de \textbf{VitalSanity}, se ha empelado el “\textbf{sandbox}” de \textbf{Mailtrap} como servidor \textbf{SMTP} de pruebas, lo cual permite interceptar y visualizar de forma segura los correos generados por la aplicación sin enviarlos a destinatarios reales. 

Para ello, en el fichero de configuración \textit{application.properties} se definen las propiedades específicas de \textbf{Mailtrap}: \\\textit{spring.mail.host=sandbox.smtp.mailtrap.io}, \textit{spring.mail.port=2525}, \textit{spring.mail.username} y \textit{spring.mail.password} con las credenciales proporcionadas por \textbf{Mailtrap}, además de habilitar el protocolo \textbf{SMTP} y \textbf{STARTTLS} \\(\textit{spring.mail.properties.mail.smtp.auth=true} y \textit{\\spring.mail.properties.mail.smtp.starttls.enable=true}) para garantizar una comunicación cifrada.



En el \textbf{pom.xml} se incluye la dependencia \textit{spring-boot-starter-mail}, que integra automáticamente el bean \textbf{JavaMailSender} y el soporte para \textbf{SimpleMailMessage}, lo que permite construir y enviar mensajes sencillos de \textbf{manera programática}.

En la clase de servicio \textbf{EmailService}, se inyecta \textbf{JavaMailSender} mediante \textbf{@Autowired} y se implementa un método unificado \textit{send(String to, String subject, String text) }que crea un objeto \textbf{SimpleMailMessage}, establece el remitente fijo \\\textbf{(“vital@sanity.es”)}, el destinatario, el asunto y el contenido del mensaje, y lo envía invocando \textit{mailSender.send(message)}.

Asimismo, para evitar bloqueos en el hilo principal de la aplicación, la invocación a \textit{emailService.send(...)} se realiza dentro de un \textbf{nuevo hilo} \textit{(new Thread(() -> { ... }).start();)}, asegurando así operaciones de envío \textbf{no bloqueantes}. Este aspecto es de \textbf{vital importancia}, puesto que aumenta el rendimiento de forma muy significativa en funcionalidades \textbf{críticas} tales como el \textbf{registro de profesionales médicos} a partir de un \textbf{fichero CSV} o todas aquellas operaciones que involucran \textbf{el flujo de firma} mediante \textbf{AutoFirma} o \textbf{Cliente móvil @firma}.

\textbf{Mailtrap} ha representado un bloque funcional \textbf{muy importante} ya que es ampliamente utilizado en un gran número de funcionalidades de la aplicación, en particular se usa para:

\begin{itemize}
    \item Enviar correo de información al paciente cuando un profesional médico le ha solicitado autorización de acceso a su historial.
    \item Enviar correo de información al profesional médico cuando un paciente ha aceptado la solicitud de autorización.
    \item Enviar correo de información al profesional médico cuando un paciente ha denegado la solicitud de autorización.
    \item Enviar correo de información al profesional médico cuando un paciente ha desautorizado el acceso a su historial médico.
    \item Enviar correo con la clave de acceso cuando un administrador registra a un centro médico.
    \item Cuando un centro médico registra a profesionales médicos a partir de un fichero \textbf{CSV}, enviar correos con las claves de acceso a cada uno de los profesionales médicos registrados.
    \item Cuando un paciente se registra, enviarle correo con el código de confirmación.
\end{itemize}
Por último, cabe destacar que aunque \textbf{Mailtrap} es una opción \textbf{excelente} y muy \textbf{intuitiva} de utilizar en \textbf{desarrollo}, para\textbf{ entornos de producción} resultaría más conveniente utilizar algún \textbf{proveedor de correo transacciona}l con características y garantías específicas como por ejemplo \textbf{Amazon SES}, \textbf{SendGrid}, \textbf{Mailgun}, \textbf{SparkPost}, \textbf{Postmark}, entre otros.


Para la utilización de \textbf{Mailtrap} en el proyecto se ha incluido la siguiente dependencia en el \textbf{pom.xml}:

\begin{figure}[H]
\centering
\includegraphics[width=0.885\textwidth, height=1\textheight, keepaspectratio]{img/mailtrap-pom-dependency.png}
\caption{Archivo de configuración \textit{Dependencia de Mailtrap en el pom.xml}}
\label{mailtrap-pom-dependency:vv}
\end{figure}

\newpage

\section{Registro de usuarios}

\subsection{Registro de centros médicos}

Los \textbf{administradores} (los cuales ya vienen preregistrados en la aplicación) se encargan de registrar a los \textbf{centros médicos} a partir de un sencillo formulario. 

Cada vez que se registra un nuevo \textbf{centro médico}, se le envía al email de dicho \textbf{centro médico} una \textbf{clave de acceso aleatoria} compuesta por doce caracteres. 

Con dicha clave de acceso, el \textbf{centro médico }podrá iniciar sesión la primera vez. No obstante, la primera vez que haya iniciado sesión, se le forzará al \textbf{centro médico} a cambiar la contraseña por una propia. El \textbf{centro médico} no podrá realizar \textbf{ninguna otra acción} dentro de la aplicación hasta que no haya cambiado su contraseña. Se \textbf{obliga} que la contraseña introducida sea de al menos ocho caracteres.

Con esta \textbf{medida} nos aseguramos de que no ocurra n\textbf{ingún riesgo} incluso si se \textbf{intercepta} la \textbf{primera} clave de acceso durante la \textbf{transmisión} del mail.

\subsection{Registro de profesionales médicos}

Los \textbf{centros médicos} son los encargados de registrar sus \textbf{profesionales médicos}. Para ello, el centro médico introduce un \textbf{fichero CSV} con todos los datos de todos los \textbf{profesionales médicos} que se quiere registrar.

Para cada \textbf{profesional médico}, primero se comprueba si dicho \textbf{profesional médico} ya estaba registrado en la base de datos para así evitar problemas de \textbf{integridad referencial}. 

Para todos aquellos \textbf{profesionales médicos} nuevos se les envía una clave de acceso. El funcionamiento de la lógica asociada a esta \textbf{clave de acceso} es \textbf{análogo} al \textbf{ya descrito} para el registro de centros médicos.

El poder registrar los profesionales médicos \textbf{a partir de un fichero CSV} es un aspecto de \textbf{gran importancia} ya que en la vida real cada centro médico está compuesto por \textbf{varios miles de profesionales médicos},  y gracias a esta funcionalidad cada centro puede registrar este elevado número de profesionales médicos de golpe, tardando \textbf{menos de un segundo} esta operación en completarse.

\subsection{Registro de pacientes}

Los \textbf{pacientes} se registran directamente desde la aplicación a través de un \textbf{sencillo formulario}. Ellos mismos introducen su \textbf{propia contraseña}. Se \textbf{obliga} a \textbf{los pacientes }que la \textbf{contraseña} introducida sea de al menos ocho caracteres.

Cuando un \textbf{paciente} termina de rellenar todos los datos del formulario, se le envía un \textbf{correo} con un \textbf{código de confirmación} conformado por \textbf{seis dígitos}. El \textbf{paciente} debe de introducir en la aplicación dicho \textbf{código de confirmación} para poder \textbf{finalizar} su \textbf{registro}.

Una vez introducido el \textbf{código de confirmación}, se le pedirá al \textbf{paciente} que complete de forma opcional sus \textbf{datos de residencia}. De esta forma, se distribuye la \textbf{carga manual} que tiene que realizar el \textbf{paciente} para \textbf{teminar de registrarse} (esquema \textbf{lazy registration}).
\chapter{Consideraciones legales}

\textbf{
\section{Cumplimiento de protección de datos}
}

La aplicación \textbf{VitalSanity} debe ajustarse estrictamente a la normativa de protección de datos, en especial al RGPD (Reglamento UE 2016/679) y a la LOPDGDD (Ley Orgánica 3/2018). Los datos de salud se consideran categorías especiales de datos que requieren protección reforzada, por lo que su tratamiento solo es lícito si se cuenta con una base jurídica adecuada y garantías elevadas de seguridad.


En este sentido, se debe respetar el derecho a la \textbf{confidencialidad} de la información médica de cada paciente: la Ley de Autonomía del Paciente (Ley 41/2002) establece que nadie puede acceder a datos sanitarios sin la debida legitimación o autorización previa del afectado. VitalSanity debe aplicar el principio de \textit{privacidad desde el diseño}, implementando medidas técnicas y organizativas robustas (control de accesos, cifrado, seudonimización, etc.) para asegurar la \textbf{integridad} y \textbf{confidencialidad} de la información. 

Igualmente, se tiene que facilitar que los pacientes ejerzan sus derechos ARSOP (acceso, rectificación, supresión, oposición, limitación del tratamiento y portabilidad) sobre sus datos personales. En concordancia con el principio de responsabilidad proactiva del RGPD, será necesario llevar un registro de actividades de tratamiento, realizar evaluaciones de riesgo y notificar a la autoridad de protección de datos cualquier brecha de seguridad relevante. 

Por último, si la escala o naturaleza del tratamiento lo requiere (p. ej., tratamiento masivo de datos de salud), se deberá designar un \textbf{Delegado de Protección de Datos (DPO)} para supervisar el cumplimiento normativo.

 \textbf{Posibilidad de revocación: }Asimismo, destacar que el consentimiento informado \textbf{no es irrevocable}; el paciente tiene derecho a retirarlo en cualquier momento. En consecuencia, \textit{VitalSanity} debe habilitar la revocación ágil de permisos previamente concedidos. Si un paciente decide denegar acceso a cierto profesional, la aplicación debe hacer efectiva esa revocación inmediatamente, notificando al sistema para que el profesional ya no pueda consultar la historia clínica. Este mecanismo de revocación es parte integral del respeto a la autonomía del paciente y debe ser tan sencillo como lo fue otorgar el permiso.

\section{  \textbf{Consentimiento informado del paciente}
}

Todo acceso o uso de información clínica a través de VitalSanity debe estar amparado por el \textbf{consentimiento informado} del paciente. La Ley 41/2002 reconoce el derecho del paciente a ser plenamente informado de cualquier actuación médica y a decidir libremente sobre la misma, exigiendo que su aceptación conste por escrito mediante un consentimiento expreso.

En línea con este mandato, VitalSanity debe asegurarse de obtener un consentimiento específico, libre e informado del paciente antes de acceder a su historial clínico o compartir sus datos, una vez que el paciente haya sido adecuadamente informado sobre las finalidades y el alcance de dicho acceso. 

Este consentimiento puede materializarse de forma digital: la aplicación debería integrar mecanismos de firma electrónica para que el paciente firme los documentos de consentimiento de manera \textbf{segura y legalmente válida}. En particular, el uso de la herramienta oficial \textbf{AutoFirma} (y su cliente móvil @firma) permitiría recabar la firma electrónica avanzada o cualificada del paciente, de conformidad con el Reglamento eIDAS, otorgándole a ese consentimiento digital la misma validez jurídica que tendría en papel.

De esta forma, se garantiza la autenticidad del consentimiento y se respeta plenamente la autonomía del paciente, dado que ningún profesional ajeno a su atención podrá acceder a sus datos de salud sin la debida autorización del propio paciente.



\textbf{
\section{Historia clínica (gestión, acceso y custodia)}
}

VitalSanity debe gestionar la \textbf{historia clínica digital} de cada paciente cumpliendo con los requisitos legales en materia de documentación sanitaria. La historia clínica es el conjunto de documentos e información relativa a la salud de un paciente, y tiene carácter \textbf{confidencial}. Solo el personal sanitario directamente implicado en la asistencia tiene permiso para acceder a ella, tal como señala la Ley 41/2002.

En consecuencia, la aplicación debe garantizar que únicamente los profesionales autorizados puedan consultar o modificar el historial clínico, implementando controles de acceso estrictos y registrando toda actividad (accesos, incorporaciones de datos, etc.) para mantener trazabilidad y detectar accesos indebidos. 

Además, VitalSanity debe preservar la \textbf{integridad} y \textbf{autenticidad} de la información clínica: cualquier dato incorporado al historial debe permanecer completo, fidedigno y asociado al profesional que lo aportó, igual que ocurriría en un expediente médico tradicional.

Por otro lado, la \textbf{custodia} legal de la historia clínica recae en el proveedor sanitario (hospital, clínica o profesional) que genera la documentación. VitalSanity, como herramienta, debe facilitar el cumplimiento de dichas obligaciones de custodia sin suplantarlas. 

Los centros sanitarios tienen el deber de archivar y conservar la documentación clínica en condiciones adecuadas de seguridad, al menos durante \textbf{cinco años} desde la fecha de alta de cada proceso asistencial (o plazos mayores según normativas autonómicas o del tipo de documento). La aplicación deberá apoyar esta conservación segura de los datos en formato electrónico, garantizando su disponibilidad cuando se requiera para la asistencia y su protección frente a pérdidas o alteraciones. 

Asimismo, debe respetarse el criterio de \textbf{unidad de la historia clínica}: cada paciente ha de tener un registro unificado por centro sanitario, que incorpore todos sus episodios asistenciales relevantes. VitalSanity debe por tanto integrarse con los sistemas de información sanitarios existentes para evitar la fragmentación de la información, asegurando que el historial clínico digital que maneja sea completo y esté sincronizado con la historia oficial del centro. 

Finalmente, se debe recordar que el paciente tiene derecho a acceder a la información de su propia historia clínica (salvo excepciones legales puntuales); la aplicación podría facilitar este derecho, por ejemplo, mediante módulos de portal del paciente, siempre cumpliendo con las garantías de seguridad y confidencialidad previstas.

\section{\textbf{Interoperabilidad entre sistemas sanitarios}}

La legislación sanitaria española promueve la \textbf{interoperabilidad} de los sistemas clínicos, con el fin de garantizar la continuidad asistencial del paciente a través de distintos niveles y centros de atención. La propia Ley 41/2002, en una disposición adicional, instó a desarrollar sistemas compatibles que permitieran el uso compartido de la historia clínica del paciente entre distintos establecimientos sanitarios, evitando duplicidades diagnósticas o pruebas innecesarias. 

Más adelante, la Ley 16/2003 de Cohesión y Calidad del SNS, en su artículo 56, encomendó al Ministerio de Sanidad coordinar con las Comunidades Autónomas los mecanismos de intercambio electrónico de información de salud, de forma que tanto los profesionales sanitarios que atienden al paciente como el propio paciente puedan acceder a los datos clínicos precisos para su asistencia, garantizando en todo caso la confidencialidad e integridad de la información.

En aplicación de este marco, se aprobó el \textbf{Real Decreto 1093/2010}, que establece el conjunto mínimo de datos comunes que deben contener ciertos informes clínicos (informes de alta, historias resumidas, etc.) en todo el Sistema Nacional de Salud.

Dicho estándar unifica el formato básico de la información para facilitar su intercambio entre los distintos servicios de salud autonómicos. 

En este contexto, VitalSanity debe ser capaz de integrarse e \textbf{interoperar} con otros sistemas sanitarios, tanto públicos como privados. Por un lado, la aplicación ha de adoptar los estándares nacionales mencionados (estructuras de datos, terminologías clínicas, formatos de intercambio como HL7/FHIR, etc.) para comunicarse eficazmente con la historia clínica digital de los servicios de salud. 

De esta forma, VitalSanity debe de cumplir con el hecho de que en España \textbf{no existen impedimentos legales} para el intercambio de información clínica entre el sector público y el privado. Para ello siempre debe de mediar el consentimiento previo del paciente. 

Esto implica que VitalSanity puede, con la autorización explícita del paciente, acceder a datos provenientes de diferentes fuentes (por ejemplo, historiales de un hospital público y de una clínica privada) y presentarlos de forma unificada al profesional o al propio paciente. La aplicación debe, por tanto, estar preparada para \textbf{respetar los protocolos de interoperabilidad} vigentes (p. ej. servicios web del Nodo de Intercambio del SNS) y a la vez \textbf{garantizar la seguridad} en esas transferencias de datos (cifrado de las comunicaciones, autenticación de los sistemas que intercambian información, etc.), de acuerdo con las exigencias legales y de las políticas de cada institución involucrada.




{
\section{Esquema Nacional de Seguridad (ENS):}
} 
Dada la naturaleza sensible de los datos de salud, es obligatorio aplicar medidas de seguridad de nivel elevado según el ENS cuando la aplicación se integra en el sector público o maneja información de pacientes de servicios públicos. El ENS, establecido por el RD 3/2010 (actualizado por RD 311/2022), proporciona un marco de buenas prácticas de seguridad orientado a proteger la información en las administraciones públicas y sus sistemas asociados\href{https://quodem.com/blog/el-papel-del-ens-en-el-sector-de-la-salud/\#:~:text=Con\%20el\%20objetivo\%20de\%20garantizar,la\%20correcta\%20gesti\%C3\%B3n\%20de\%20estos}{quodem.com}. VitalSanity debe alinearse con estas exigencias, implementando controles como autenticación robusta (ej. \textbf{autenticación con certificado digital}), gestión estricta de permisos de usuario, cifrado de las comunicaciones, registro y monitorización de accesos, planes de respuesta ante incidentes, copias de seguridad, entre otras medidas. Cumplir con el ENS garantiza un nivel de protección acorde al exigido en el ámbito sanitario público y refuerza la confianza en la aplicación.

\section{Reglamento eIDAS y firma electrónica}
 El Reglamento (UE) n.º 910/2014 \textbf{eIDAS} sobre identificación electrónica y servicios de confianza, junto con la Ley 59/2003 española de firma electrónica, establecen las condiciones bajo las cuales una \textbf{firma electrónica avanzada o cualificada} tiene el mismo valor legal que la firma manuscrita en documentos oficiales. En el contexto de VitalSanity, esto implica que los consentimientos informados y demás documentos clínicos firmados digitalmente a través de la aplicación (por ejemplo, utilizando certificados digitales reconocidos mediante AutoFirma) gozarán de plena validez jurídica. La plataforma debe, por tanto, utilizar certificados y métodos de firma electrónica que cumplan estos estándares, garantizando la \textbf{autenticidad}, \textbf{integridad} y el \textbf{no repudio} de los documentos firmados. De esta forma, tanto pacientes como profesionales pueden firmar electrónicamente consentimientos, informes o autorizaciones con la certeza de que dichos actos tienen eficacia legal y probatoria equivalente a los tradicionales en papel.
 
 
\section{Consideraciones éticas}
 Más allá del cumplimiento legal, la gestión de datos de salud conlleva importantes responsabilidades éticas. VitalSanity debe adherirse a los \textbf{principios éticos} que rigen la relación sanitario-paciente y el uso de información sensible. Esto incluye el respeto estricto del \textbf{secreto profesional} y la privacidad del paciente: toda persona que acceda a datos mediante la aplicación debe estar sujeta a deberes de confidencialidad profesionales. Igualmente, el principio de \textbf{autonomía del paciente} exige que las decisiones sobre el uso de sus datos estén centradas en su consentimiento y preferencias, evitando cualquier forma de coerción o uso indebido de la información. La \textbf{beneficencia} y la \textbf{no maleficencia} han de guiar el diseño de la herramienta: sus funcionalidades (por ejemplo, algoritmos de ayuda a la decisión clínica) deben buscar mejorar la calidad de la atención sin causar perjuicios ni discriminar pacientes. Es aconsejable que VitalSanity se desarrolle bajo un enfoque de \textit{ética de datos}, asegurando transparencia en cómo se usan los datos, minimizando la recopilación a lo necesario y garantizando un uso justo y responsable de la información (por ejemplo, si se utilizan datos anónimos para investigación, hacerlo con las debidas autorizaciones de comité ético). 

  






\appendix
\chapter{Bibliografía}\label{enlaces}

Destacar que para la realización de este trabajo se ha empleado únicamente como referencia el material proporcionado  en la asignatura de Gestion de Calidad Software, así como el uso de la IA ya mencionado. 

A continuación, se adjuntan los enlaces de descarga de las aplicaciones mencionadas en el apartado de 'Análisis de competencia':

\begin{itemize}

\item Descarga de la aplicación 'Flush - Public Toliet Finder': \url{https://play.google.com/store/apps/details?id=toilet.samruston.com.toilet}

\item Descarga de la aplicación 'OstomiAseo': \url{https://play.google.com/store/apps/details?id=com.viacoreit.ostomiaseo}

\item Descarga de la aplicación 'Toilet Finder': \url{https://play.google.com/store/apps/details?id=com.bto.toilet}

\end{itemize}

\end{document}
