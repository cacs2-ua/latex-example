\documentclass[a4paper,twoside,openright,12pt]{book}
\usepackage[
  inner=3cm,      % margen de encuadernación
  outer=2.5cm,    % margen exterior
  top=2.5cm,
  bottom=2.5cm
]{geometry}
\usepackage{setspace}
\onehalfspacing
\setlength{\parskip}{0.75\baselineskip}  % ← prueba con 0.5–1.0 \baselineskip
\setlength{\parindent}{20pt}             % ← conserva la sangría habitual
\raggedbottom 
\usepackage[spanish]{babel}
\usepackage{mathpazo}
\usepackage{graphicx}
\usepackage{caption}
\captionsetup[figure]{skip=10pt, labelfont=bf}
\usepackage[utf8]{inputenc} % Para poner acentos y eñes directamente.
\usepackage{pdfpages}
\usepackage{listings}
\usepackage[T1]{fontenc}
\usepackage{hyperref}
\usepackage{algorithm2e}
\usepackage{float} 

\setcounter{tocdepth}{3}
\setcounter{secnumdepth}{3}




\usepackage{fancyhdr}
\pagestyle{fancy}
\fancyhf{}  % limpia encabezados y pies

% Actualiza marks para dos caras
\renewcommand{\chaptermark}[1]{\markboth{\thechapter.\ #1}{}}
\renewcommand{\sectionmark}[1]{\markright{\thesection.\ #1}}

% Cabeceras/pies diferenciados par (E) / impar (O)
\fancyhead[RO]{\thepage}                            % página en el lado derecho impar
\fancyhead[LE]{\thepage}                            % página en el lado izquierdo par
\fancyhead[LO]{\nouppercase{\textit{\rightmark}}}   % sección en impar (izq.)
\fancyhead[RE]{\nouppercase{\textit{\leftmark}}}    % capítulo en par (der.)


\usepackage{titlesec}
\titleformat{\chapter}[display]
  {\normalfont\fontfamily{phv}\selectfont\Huge\bfseries}{}
  {0pt}{\Huge}
\titleformat{\section}
  {\normalfont\fontfamily{phv}\selectfont\Large\bfseries}{\thesection}{1em}{}

\usepackage{courier} % Esto configura \ttfamily a Courier
\lstset{basicstyle=\fontfamily{pcr}\selectfont}

\SetAlFnt{\fontfamily{pcr}\selectfont\footnotesize}




\renewcommand{\textsharp}{$\sharp$}

\begin{document}

\includepdf[pages={1}]{portadas/VitalSanity-Portada.pdf}

\thispagestyle{empty} % para que no se numere esta pagina

\null
\newpage


\includepdf[pages={1}]{portadas/VitalSanity-Second-Portada.pdf}

\thispagestyle{empty} % para que no se numere esta pagina

\null
\newpage

\chapter*{Agradecimientos}

\pagenumbering{arabic}    % ← usa números “normales”
\setcounter{page}{1}      % ← (opcional) empieza en la 1

\addcontentsline{toc}{chapter}{Agradecimientos} % si queremos que aparezca en el índice
\markboth{AGRADECIMIENTOS}{AGRADECIMIENTOS} % encabezado
\thispagestyle{empty} % para que no se numere esta pagina

Agradecer este trabajo a mi familia por la ayuda y el apoyo que me han dado para llegar a crear este documento que mezcla dos mundos muchas veces duros de conllevar.

A mi tutor, Carlos, por orientar de una manera sencilla el proyecto y ser honesto con los objetivos propuestos.

A mis compañeros y profesores del grado, con los que he compartido muy buenos momentos y mucha experiencia profesional.

\clearpage                % cierra Agradecimientos
\thispagestyle{empty}     % la página que viene irá SIN cabecera ni pie
\null
\clearpage                % pasa a la siguiente página «normal»


\chapter*{}
\begin{flushright}
  \textit{Cuando cambias la solución, es evolución. \\
          Cuando cambias la pregunta, es revolución.}
  \\[\baselineskip]
  --- Jorge Wagensberg
\end{flushright}


\clearpage                
\thispagestyle{empty}    
\null
\clearpage                


\tableofcontents % indice de contenidos

\cleardoublepage
\addcontentsline{toc}{chapter}{Lista de figuras} % para que aparezca en el indice de contenidos
\listoffigures % indice de figuras


\clearpage                
\thispagestyle{empty}    
\null
\clearpage  

\chapter{Estado del arte}
\section{Productos similares actualmente en el mercado}
\subsection{HCDSNS - España} 
En España, el Ministerio de Sanidad ha impulsado la HCDSNS (Historia Clínica Digital del Sistema Nacional de Salud) como un repositorio electrónico unificado de información sanitaria esencial, accesible tanto para profesionales autorizados como para los propios ciudadanos.

Esta plataforma nacional permite que un médico en cualquier comunidad autónoma consulte informes clínicos generados en otra región, facilitando la continuidad asistencial en todo el país y evitando pruebas duplicadas. La HCDSNS opera bajo estrictos criterios de seguridad: el acceso requiere autenticación robusta (DNIe, certificados electrónicos o sistema Cl@ve) y queda limitado a fines asistenciales. 


\subsection{Proyecto de Historia Clínica Interoperable - España}
El sector sanitario privado español, aglutinado en la Fundación IDIS, ha desarrollado una plataforma pionera de historia clínica compartida de ámbito nacional para sus pacientes: El Proyecto de Historia Clínica Interoperable en la Sanidad Privada. A finales de 2023 ya contaba con unos\textbf{ 57.000} \textbf{usuarios conectados} y la participación de al menos 15 entidades sanitarias privadas relevantes (grupos hospitalarios y aseguradoras médicas). 

Esta iniciativa permite que un paciente de la sanidad privada \textbf{acceda a su historial clínico unificado} a través de un portal web o aplicación y pueda \textbf{compartir dicha información –totalmente o por informes seleccionados– con el profesional sanitario que él elija}, independientemente del centro u hospital al que pertenezca dicho profesional. 

En cuanto a \textbf{seguridad} de esta aplicación, la directriz es equiparable al sistema público: solo profesionales autorizados pueden acceder, mediante credenciales seguras, y se incorporan mecanismos de alerta ante cualquier intento de acceso no autorizado a datos privados. “Nos tenemos que sentir seguros, confiados”, destacó la Dirección de IDIS al subrayar que se está diseñando un sistema con alertas que saltan si alguien intenta \textbf{invadir un dato privado}, garantizando así la privacidad del paciente. 


\subsection{Epic MyChart - Internacional}
MyChart es la plataforma de portal de pacientes de Epic, que permite consultar medicaciones, resultados de pruebas, citas, facturación y presupuestos de forma centralizada para más de 190 millones de pacientes en múltiples organizaciones sanitarias. Además, incorpora comunicaciones seguras entre paciente y profesional y videovisitas integradas.

\subsection{Cerner Patient Portal - Estados Unidos}
Ofrece acceso al Registro Médico Electrónico (EMR) mantenido por el proveedor, con vistas seguras a informes clínicos y comunicación bidireccional entre paciente y profesional. Dispone de funcionalidades para descargar y compartir registros con otros profesionales.

\subsection{Carpeta Personal de Salud (CPS) AppSalut - Cataluña}
Iniciativa pública que facilita la prescripción e integración de apps sanitarias acreditadas, mostrando gráficos de evolución de datos y permitiendo a profesionales seleccionar información para integrar en la historia clínica. Asimismo, ofrece al ciudadano visualización de datos generados en el sistema público catalán y filtros avanzados.


\subsection{Dossier Médical Partagé (DMP) – Francia}
A nivel europeo, Francia ha implementado desde 2018 el Dossier Médical Partagé, un expediente médico electrónico \textbf{personal y seguro} para cada ciudadano francés. Su objetivo es servir como \textbf{historia clínica digital unificada}: almacena informes médicos, resultados de pruebas, antecedentes de salud, alergias, informes de hospitalización e incluso las voluntades anticipadas del paciente. 

El DMP busca \textbf{mejorar la coordinación y continuidad asistencial }centralizando los datos médicos en un “carné de salud” electrónico accesible en línea. Cada ciudadano puede crear gratuitamente su DMP y gestionar quién tiene acceso: \textbf{el paciente mantiene siempre el control sobre quién consulta su expediente}, pudiendo añadir información personal relevante u \textbf{ocultar determinados documentos} para que no sean visibles a profesionales, según su preferencia. De hecho, el sistema envía notificaciones (por correo electrónico) cada vez que se añade un nuevo documento al expediente, reforzando la transparencia hacia el titular de los datos. 


\subsection{Elektronische Patientenakte (ePA) - Alemania}

En \textbf{Alemania}, se ha introducido la Elektronische Patientenakte, un expediente electrónico del paciente promovido por las aseguradoras públicas, donde el ciudadano puede gestionar sus registros médicos digitales a través de aplicaciones móviles y controlar el acceso de médicos a dichos datos mediante consentimientos específicos. 

\subsection{Expedientes médicos centralizados en Estonia}
En \textbf{Estonia}, todo ciudadano posee un expediente médico digital centralizado: los profesionales sanitarios acceden a la información con autorización, y el paciente puede revisar en un portal quién ha consultado su historial, pudiendo bloquear el acceso a determinados datos si así lo desea (salvo en emergencias).

\section{Objetivos comunes en este tipo de soluciones}
Los ejemplos anteriores, tanto públicos como privados, evidencian una serie de \textbf{objetivos comunes} en las soluciones de historial clínico centralizado y acceso compartido:

\begin{itemize}

\item \textbf{Continuidad asistencial y disponibilidad universal de datos}: Unificar la información médica del paciente para que esté disponible desde \textbf{cualquier centro o región}, evitando fragmentación de datos. Esto permite a cada profesional sanitario autorizado consultar antecedentes relevantes (alergias, medicación, diagnósticos previos) aunque sea la primera vez que atiende al paciente. El acceso unificado reduce la repetición de pruebas diagnósticas innecesarias y mejora la coordinación entre niveles asistenciales, brindando una atención más eficiente y segura.
\item \textbf{Empoderamiento del paciente y control sobre la privacidad: } Poner al paciente en el centro, otorgándole acceso directo a su historia clínica y la capacidad de decidir quién más puede verla. Todas las plataformas coinciden en \textbf{requerir el consentimiento del paciente} para compartir sus datos con terceros, en línea con la normativa de autonomía del paciente.
\item \textbf{Seguridad de la información y cumplimiento legal: } Dada la naturaleza altamente sensible de los datos de salud, estas soluciones comparten el objetivo de garantizar \textbf{la confidencialidad, integridad y disponibilidad} de la información clínica. Implementan autenticación fuerte (certificados digitales, identidades electrónicas verificadas) para el acceso tanto de profesionales como de pacientes, utilizan conexiones cifradas y centros de datos seguros, y se ajustan a las exigencias legales (GDPR en Europa, Ley Orgánica de Protección de Datos y Garantía de Derechos Digitales en España, etc.). La \textbf{trazabilidad} de cada acción (quién accede, cuándo y qué consulta) y la generación de \textbf{alertas ante accesos no autorizados} constituyen prácticas habituales para proteger los datos. Igualmente, se fomenta el almacenamiento seguro de la información, con copias de respaldo y planes de contingencia, para garantizar que el historial clínico centralizado esté disponible incluso ante fallos técnicos o desastres.
\item \textbf{Mejora de la eficiencia y reducción del papel: } Estas aplicaciones digitalizan la documentación clínica redunda en una gestión más ágil y sin papel de los procesos sanitarios. Un objetivo común es eliminar trámites físicos engorrosos: por ejemplo, sustituyendo los consentimientos informados y otros formularios en papel por \textbf{documentos electrónicos firmados digitalmente}. La firma electrónica integrada en estas plataformas permite que pacientes y profesionales firmen autorizaciones, consentimientos o informes de alta de forma \textbf{remota o presencial}, con plena validez legal, quedando el documento almacenado de forma segura en el sistema. 

\end{itemize}


\section{Similitudes con VitalSanity}
Con todo esto, la propuesta de VitalSanity se inscribe en una tendencia clara de digitalización sanitaria centrada en el paciente, compartiendo muchos de los pilares funcionales con las soluciones actuales del mercado. Al igual que las plataformas públicas nacionales (HCDSNS en España, DMP en Francia) y los portales integrados privados, VitalSanity busca ofrecer una historia clínica electrónica centralizada donde el paciente pueda reunir todo su historial médico y ejercer un control activo sobre él. 

Se puede observar de forma evidente que las similitudes son notables: VitalSanity pone énfasis en la autorización por parte del paciente para cualquier acceso a datos (siguiendo el principio de consentimiento informado y gestión granular de la privacidad, como ya implementan HCDSNS o DMP) y promete un almacenamiento seguro de la información sensible, alineado con las mejores prácticas de seguridad y la normativa europea de protección de datos. 

Asimismo, VitalSanity incorpora la firma electrónica de documentos médicos como parte integral de sus funcionalidades, permitiendo digitalizar procesos que en muchos entornos aún se realizan en papel (por ejemplo, la firma de consentimientos informados o la compartición de informes entre profesionales). Este enfoque multidisciplinar –que combina expediente clínico interoperable, portal del paciente y firma digital avanzada– coincide con el objetivo general del sector de lograr una sanidad sin barreras físicas ni administrativas, donde el flujo de información médica sea instantáneo pero siempre bajo el control del titular de los datos.

Ahora bien, no nos podemos olvidar de que VitalSanity también enfrenta el desafío de diferenciarse y aportar valor añadido en un panorama donde ya existen iniciativas consolidadas. Una diferencia potencial radica en el alcance y la integración: mientras las soluciones públicas suelen limitarse al ámbito del sistema regional de salud, y las privadas tienden a circunscribirse a las redes de determinados grupos hospitalarios o aseguradoras, VitalSanity se presenta como una plataforma agnóstica al proveedor, capaz de agregar información de múltiples fuentes (públicas y privadas) en un único expediente longitudinal del paciente. 

Esto supone un nivel extra de interoperabilidad, sirviendo de puente entre silos de información que hoy permanecen parcialmente desconectados. De esta forma, un usuario de VitalSanity puede visualizar en su cuenta tanto los informes de una intervención quirúrgica realizada en un hospital público, como los resultados de unas pruebas diagnósticas efectuadas en una clínica privada, y compartir ambos con su médico de cabecera de forma sencilla.



Por todo lo ya mencionado, VitalSanity se alinea con la dirección en la que evoluciona la sanidad digital, proporcionando funcionalidades que son hoy por hoy indispensables –centralización del historial, acceso multidisciplinar con permiso del paciente, firma electrónica y alta seguridad– y debe competir en confiabilidad, alcance y facilidad de uso con soluciones ya operativas. 

El éxito de VitalSanity depende de su capacidad para igualar y superar los estándares ya marcados por iniciativas públicas y privadas (en términos de seguridad jurídica, interoperabilidad y cumplimiento normativo) y a la vez innovar en ámbitos como la integración total de fuentes de datos y la experiencia de usuario. De lograr este equilibrio, VitalSanity podría aspirar (una vez puesta en producción) a posicionarse sólidamente en el panorama actual, aportando una visión unificada del historial clínico del paciente y anticipándose a las futuras tendencias, donde el paciente empoderado y el intercambio seguro de información constituyen la piedra angular de los sistemas de salud.






\chapter{Aspectos de seguridad}


\section{Seguridad en la Firma Digital de Documentos}
La autenticación de usuarios en \textbf{VitalSanity} se realiza mediante certificados digitales \textbf{X.509}, integrados en la plataforma a través de \textbf{Spring Security} y aprovechando la integración \textbf{nativa} de Spring Security con el protocolo \textbf{X.509}. Cada usuario  debe \textbf{identificarse con un certificado digital reconocido} y su correspondiente clave privada, lo que proporciona un nivel alto de seguridad en la verificación de la identidad. En la práctica, esto implica que el sistema solo permite el acceso a quienes posean un certificado válido emitido por una Autoridad de Certificación de confianza (por ejemplo, el DNIe o certificados de la FNMT), aumentando significativamente la protección frente a accesos no autorizados o suplantación de identidad.


Cabe destacar de que en la aplicación también se ha incluido la opción tradicional de iniciar sesión con email y contraseña. Esto se ha realizado para poder realizar las pruebas pertinentes en la aplicación durante desarrollo (debido a que se necesitaba crear múltiples usuarios y trabajar con múltiples usuarios y roles para poder probar todas las funcionalidades de la aplicación). Cabe destacar de que en producción se eliminaría esta opción de iniciar sesión con email y contraseña, imponiendo a los usuarios el autenticarse mediante un certificado digital válido para así defenderse de forma robusta frente a accesos no autorizados o suplantación de identidad, consiguiendo de esta manera una seguridad muy potente a la hora de acceder al sistema.

Por otra parte, la plataforma verifica rigurosamente la validez del certificado presentado en cada inicio de sesión. Este proceso incluye la comprobación de que el certificado \textbf{no haya sido revocado} y que siga siendo \textbf{plenamente válido para identificar a su propietario}. Solo tras superar todas estas verificaciones, Spring Security \textbf{autentica al usuario} y le concede acceso a las funciones de la aplicación. Este mecanismo de autenticación basada en certificados digitales ofrece garantías de seguridad equiparables a la autenticación de múltiples factores, pues requiere algo que el usuario \textbf{posee} (su certificado y clave privada) y algo que el usuario \textbf{es} (su identidad avalada por el certificado). Gracias a ello, VitalSanity asegura que únicamente personas autorizadas puedan acceder a datos sensibles, evitando accesos indebidos incluso en entornos distribuidos o remotos.


\section{Seguridad en la Firma Digital de Documentos}
VitalSanity incorpora el uso de herramientas oficiales de \textbf{firma electrónica} proporcionadas por el Gobierno de España para garantizar la autenticidad e integridad de los documentos clínicos generados en la plataforma. En particular, se utiliza la aplicación \textbf{AutoFirma}, así como su \textbf{cliente móvil @firma}, para la firma digital de autorizaciones de pacientes y de informes médicos emitidos por los profesionales sanitarios. AutoFirma, desarrollada por el Ministerio de Hacienda y Administraciones Públicas, es parte de la suite @firma y permite realizar la firma electrónica de documentos cumpliendo con estándares abiertos, \textbf{garantizando la interoperabilidad y la seguridad en las transacciones electrónicas}. De este modo, cada vez que un médico emite un informe o un paciente otorga una autorización en VitalSanity, el documento correspondiente es firmado digitalmente mediante un certificado electrónico reconocido, usando AutoFirma en entornos de escritorio o el Cliente @firma en dispositivos móviles.


El empleo de \textbf{certificados digitales reconocidos} en la firma confiere a los documentos un alto nivel de protección: \textbf{integridad}, porque cualquier alteración posterior invalida la firma digital; \textbf{autenticidad}, porque vincula criptográficamente la identidad del firmante al documento; y \textbf{no repudio}, ya que el firmante no puede negar la autoría de la firma. Estas propiedades son cruciales tratándose de autorizaciones sanitarias e informes médicos, que requieren la máxima fiabilidad y validez legal. Cabe destacar que las soluciones de la suite @firma están alineadas con la normativa española y europea de firma electrónica (eIDAS), por lo que las firmas generadas a través de AutoFirma gozan de reconocimiento legal equivalente a la firma manuscrita. VitalSanity garantiza que todos los documentos críticos se firman digitalmente de forma segura y \textbf{formalmente válida}, fortaleciendo la confianza en la documentación clínica intercambiada a través de la aplicación.

\section{Protección de los Datos en el Almacenamiento}
En \textbf{VitalSanity}, los datos sensibles (historias clínicas, informes, consentimientos firmados, imágenes médicas, etc.) se almacenan de forma segura utilizando \textbf{Amazon Web Services (AWS)}, concretamente en \textbf{buckets de Amazon S3} dedicados. Estos repositorios de almacenamiento en la nube están configurados como privados y se han implementado controles estrictos para su acceso. La aplicación nunca expone directamente los contenidos almacenados; en su lugar, utiliza \textbf{URLs prefirmadas} de S3 para cualquier acceso a documentos. Una URL prefirmada es un enlace temporal generado por la aplicación que concede acceso limitado a un objeto (archivo) específico en S3, sin necesidad de revelar credenciales o permisos permanentes de AWS. Estas URLs prefirmadas incorporan \textbf{tokens de seguridad y expiración}: solo el usuario autorizado puede utilizar el enlace, y además este caduca tras un intervalo breve predefinido, impidiendo accesos posteriores no autorizados. Gracias a este mecanismo, si un tercero intenta acceder directamente a los buckets de S3 sin un enlace válido, la solicitud será denegada. En esencia, las URLs prefirmadas actúan como pases de acceso de un solo uso y con vigencia limitada, garantizando que los datos clínicos almacenados solo sean accesibles para quienes tengan derechos y solo durante el tiempo.


Por otro lado, VitalSanity protege la \textbf{confidencialidad de los datos en reposo} mediante cifrado robusto administrado con un \textbf{gestor de claves (KMS) personalizado}. Para todos los ficheros y datos almacenados en AWS S3, se habilita el \textbf{cifrado del lado del servidor con AWS KMS} (AWS Key Management Service), utilizando una clave de cifrado \textbf{CMK} propia  de la aplicación. Esto implica que cada objeto se almacena cifrado criptográficamente; solo a través de la clave CMK correspondiente (custodiada de forma segura) puede descifrarse su contenido. VitalSanity, al hacer uso de esta \textbf{clave CMK administrada por el cliente}, esto implica que la organización mantiene control total sobre el ciclo de vida y el uso de dichas. 


Este enfoque –recomendado por AWS para clientes que requieren un control granular de sus llaves criptográficas– permite definir políticas estrictas sobre quién o qué componentes de la aplicación pueden usar las claves para desencriptar información. En la práctica, incluso si alguien no autorizado consiguiera acceder al bucket de almacenamiento, los datos allí contenidos permanecerían ininteligibles gracias al cifrado. Adicionalmente, la gestión personalizada que ofrece KMS  da pie a poder utilizar rotación periódica de claves y registros de auditoría (vía AWS CloudTrail) de cada uso de las claves, añadiendo trazabilidad y cumplimiento de políticas de seguridad corporativas. Todo este conjunto de medidas asegura que la información médica en VitalSanity esté protegida tanto \textbf{en tránsito} (mediante conexiones HTTPS cifradas cuando se transfieren los datos) como \textbf{en reposo} (almacenada cifradamente en S3), alcanzando un nivel de seguridad acorde a la naturaleza crítica de dichos datos.







\chapter{Metodologías empleadas}



\section{Flujo de trabajo Gitflow (con Pull Requests)}
Para el desarrollo de la aplicación se ha empleado el flujo de trabajo \textbf{GitFlow} para gestionar las ramas (branches) de Git, complementado con el uso de \textbf{Pull Requests} para la integración de cambios. 

GitFlow es un modelo de ramificación ampliamente conocido que \textbf{describe el ciclo de lanzamiento del proyecto asignando roles específicos a distintas ramas} y definiendo \textbf{cuándo y cómo deben interactuar} entre sí. En este modelo se distinguen principalmente dos ramas permanentes: la rama \textbf{principal} (master o main), que almacena el historial oficial de lanzamientos estables, y la rama \textbf{de desarrollo} (develop), que es el punto de integración de las nuevas funcionalidades. 

A partir de ellas, GitFlow emplea ramas de soporte de vida corta para estructurar el trabajo: las ramas \textbf{de funcionalidad} (feature branches), creadas desde develop para desarrollar cada nueva característica o mejora; las ramas \textbf{de lanzamiento} (release branches), que se crean desde develop cuando se acumulan suficientes funcionalidades para preparar una versión pública, permitiendo pulir detalles finales (ej. corrección de bugs, documentación) sin detener el desarrollo de nuevas funciones; y las ramas \textbf{de corrección rápida} (hotfix branches), que se derivan directamente de master/main cuando es necesario corregir de urgencia un fallo en producción, aplicando el arreglo y luego fusionándolo tanto a master como a develop.

Este esquema, propuesto originalmente por Vincent Driessen, impone una disciplina en la gestión de versiones: la rama develop siempre contiene el código en estado integrador (inestable pero con las últimas novedades), mientras que master/main solo recibe código que ha pasado por un ciclo completo de pruebas y está listo para liberación. Cada fusión significativa va acompañada de un \textbf{número de versión}. Por ejemplo, al fusionar develop en master tras completar un conjunto de funcionalidades, se etiqueta una nueva versión de lanzamiento (vX.Y.Z). Esta estrategia de ramificación organizada alrededor de las publicaciones del proyecto ayuda a mantener la estabilidad en la rama principal y a aislar el desarrollo de nuevas características hasta que estén maduras.

El uso de \textbf{Pull Requests (PR)} en este flujo aporta un nivel adicional de control y revisión. Una pull request es una petición formal para incorporar los cambios de una rama en otra, usualmente acompañada de una discusión o revisión de código. Integrar pull requests dentro de GitFlow proporciona a los desarrolladores (en este caso, al desarrollador y su tutor) un espacio conveniente para \textbf{discutir los cambios de una rama antes de fusionarlos}.

Cuando una rama está lista, se crea una pull request para que su contenido sea evaluado antes de integrarse a develop; de modo similar, se utilizan pull requests al preparar una rama de lanzamiento o al aplicar un hotfix, asegurando de esta forma que dichos cambios sean revisados y aprobados antes de incorporarlos tanto a develop como a main. Las pull requests actúan de este modo como \textbf{puntos de control de calidad}: permiten revisar el código, comentar sobre él, etc. 

\subsection{Importancia de Gitflow para el desarrollo de la aplicación}
Se ha empleado GitFlow con el objetivo de \textbf{ordenar el proceso de integración de código}, evitando confusiones y manteniendo versiones estables del proyecto a lo largo del tiempo. Esta metodología ha sido de gran utilizad para asegurar que la rama principal siempre esté lista para una posible entrega o demostración, mientras el desarrollo cotidiano ocurre en ramas separadas. GitFlow facilita tener esas versiones listas sin frenar la incorporación de nuevas ideas en paralelo.

El flujo GitFlow con pull requests dota a la aplicación de un \textbf{proceso de desarrollo estructurado, colaborativo y trazable}, adecuado tanto para garantizar la robustez del resultado final como para poner en evidencia el rigor en la gestión del proyecto.

\newpage

\section{Versionado Semántico}
Como complementación a Gitflow, Se ha empleado \textbf{Versionado Semántico} (Semantic Versioning o \textbf{SemVer}) para asignar identificadores de versión a la aplicación. 

El versionado semántico es una convención ampliamente adoptada 
que define un formato \textbf{MAJOR.MINOR.PATCH} para los números de versión, donde cada componente numérico transmite información sobre la naturaleza de los cambios realizados. En concreto, la especificación SemVer 2.0.0 establece las siguientes reglas:

\begin{itemize}
  \item \textbf{MAYOR (Major)}: Se incrementa la versión mayor cuando se introducen \textbf{cambios incompatibles} con versiones anteriores (por ejemplo, modificaciones que rompen la compatibilidad de la API o eliminan funcionalidad previa).
  \item \textbf{MENOR (Minor)}: Se incrementa la versión menor cuando se añade \textbf{nueva funcionalidad de forma compatible} con la versión existente. Es decir, mejoras o características adicionales que mantienen la compatibilidad hacia atrás.
  \item \textbf{PARCHE (Patch)}: Se incrementa la versión parche cuando se realizan \textbf{correcciones de errores o cambios menores compatibles} con versiones previas. Son típicamente arreglos que no afectan la funcionalidad de forma sustancial ni rompen compatibilidad.
\end{itemize}

La esencia de esta metodología de versionado es transmitir claramente el significado y alcance de los cambios a través del número de versión. Gracias al versionado semántico también se evita el denominado \textbf{infierno de dependencia}s al establecer expectativas claras sobre la compatibilidad de la aplicación.

\subsection{Importancia del versionado semántico para el desarrollo de la aplicación}
La aplicación de versionado semántico en VitalSanity ha tenido como objetivo el de proporcionar un \textbf{esquema claro y consistente} para identificar cada entrega o iteración del software. Dado que el proyecto ha constado de diferentes fases, etiquetar cada liberación con un número de versión semántica contribuye a obtener una mejor comprensión de la \textbf{relevancia de cada versión}. 

La elección del versionado semántico como metodología se justifica por ser un \textbf{estándar ampliamente reconocido} en la industria del software (adoptado por multitud de proyectos y plataformas) y por proveer un conjunto de reglas objetivo para el versionado.  Un esquema de versionado claro facilita las discusiones sobre avances en el proyecto (por ejemplo, \textbf{en la versión 1.2.1 se incorporó la funcionalidad X}) y respalda la trazabilidad de la evolución del software. 

\newpage

\section{Planificación y seguimiento de tareas}

Para la \textbf{planificación y seguimiento} de las tareas del proyecto se ha empleado la metodología \textbf{Kanban}. Kanban es un marco de trabajo ágil que enfatiza la visualización continua del trabajo y la transparencia total del flujo de tareas. En Kanban, los elementos de trabajo (tareas, funcionalidades, etc.) se representan en tarjetas dispuestas en columnas que típicamente reflejan estados como Pendiente, En progreso y Terminado. Este tablero visual permite conocer de un vistazo el estado de cada tarea en cada momento. 

Esta funcionalidad se ha empleado tanto en un tablero Trello como en un tablero de GitHub Project asociado al repositorio de GitHub de VitalSanity.


\subsection{Importancia de Kanban para el desarrollo de la aplicación} La utilización de Kanban tiene como objetivo organizar el trabajo de forma visual y eficiente, priorizando las tareas e incrementando la transparencia del estado del proyecto.  El uso de Kanban ha servido para obtener un control estructurado pero flexible de las tareas, mejorando la gestión del tiempo y la productividad durante el desarrollo.

\newpage

\section{Reuniones periódicas de seguimiento}
Es importante destacar también las \textbf{reuniones periódicas} de seguimiento y con mi tutor de TFG Carlos.

Dichas reuniones han resultado de gran utilidad para revisar el progreso, resolver dudas, recibir orientación y asegurar que el proyecto se iba encaminando al cumplimiento de sus objetivos. Asimismo, todas estas reuniones han servido para detectar riesgos o desviaciones a tiempo y proponer correcciones o mejoras en cada sesión.

\subsection{Importancia de las reuniones periódicas para el desarrollo de la aplicación} 
La agenda de reuniones periódicas ha tenido como objetivo el de garantizar un \textbf{seguimiento continuo} del proyecto y una alineación constante con los objetivos planteados, asegurando que el desarrollo técnico estuviese respaldado por un control académico sólido.


\newpage




\chapter{Detalles de Implementación}

En este apartado se describirán los detalles más significativos e importantes a nivel de código que presenta la aplicación desarrollada



\section{Modelo Vista Controlador}

Se ha empleado una arquitectura \textbf{MVC} para desarrollar VitalSanity. En Springboot, esta arquitectura se materializa de la siguiente manera:


\begin{enumerate}
    \item \textbf{Modelo}
    \begin{itemize}
        \item Representa la \textbf{lógica de negocio} y los \textbf{datos} de la aplicación: entidades JPA, DTOs, servicios, repositorios. 
        \item Encapsula el acceso a la base de datos y las reglas de negocio, aislando el estado de la aplicación de la presentación. 
    \end{itemize}


    \item \textbf{Vista}
    \begin{itemize}
        \item Define la \textbf{interfaz de usuario}, en este caso, plantillas Thymeleaf.
        \item Se encarga únicamente de mostrar los datos que recibe del controlador y de capturar la interacción del usuario. 
    \end{itemize}


    \item \textbf{Controlador}
    \begin{itemize}
        \item Gestiona las \textbf{peticiones HTTP} entrantes (\verb|@Controller| / \verb|@RestController|). 
        \item Invoca los servicios del modelo para procesar datos, y devuelve la vista adecuada junto con el \textbf{modelo de datos} (un \verb|Model| o un objeto JSON). 
    \end{itemize}
\end{enumerate}


Las principales ventajas de aplicar el patrón \textbf{MVC} son la \textbf{reutilización, la testeabilidad, la escalabilidad y el cumplimiento del principio de Separación de responsabilidades} (Cada capa del sistema presenta una única función bien definida, de forma que nunca se mezclan la lógica de negocio, la lógica de acceso a datos y la lógica de presentación).


\section{Autenticación con certificado digital}

\subsection{Configuración del conector extra HTTPS  }

\begin{itemize}
\item La clase \verb|config/AdditionalHttpsConnectorConfig|, anotada con \\\verb|@Configuration|, se encarga de añadir un conector HTTPS adicional al servidor embebido de Tomcat en Spring Boot, configurando tanto el almacén de claves del servidor (keystore) como el almacén de confianza (truststore, el cual contiene los certificados de autoridad) para habilitar  TLS mutuo con verificación obligatoria del certificado de cliente. 
\item En primer lugar, se inyectan mediante \verb|@Value| las propiedades relativas al almacén de claves del servidor (ruta, contraseña, tipo y alias) y al almacén de confianza para validar certificados de cliente. A través del método \\\verb|servletContainer()| se crea un \verb|TomcatServletWebServerFactory| al que se agrega un conector personalizado definido en \verb|createSslConnector()|. Este conector escucha en el puerto 8059, fuerza el esquema \verb|https| y activa SSL en el protocolo \verb|Http11NioProtocol|. 
\item A continuación, se construye un \verb|SSLHostConfig| que impone la verificación de certificado de cliente (\verb|required|),  incorpora una lista de revocación de certificados (CRL), y se asocia el truststore para validar las cadenas de certificado entrantes. 
\item Despúes, se crea un \verb|SSLHostConfigCertificate| de tipo RSA, que carga el keystore del servidor con sus credenciales y alias, y se añade a la configuración SSL del conector. De este modo, la aplicación autentica de forma mutua tanto al cliente como al servidor antes de procesar cualquier petición relacionada con la autenticación por certificado digital. 
\end{itemize}

\subsection{Filtro de preautenticación X.509}

\begin{itemize}
    \item La clase \verb|SecurityConfig| configura, con la máxima prioridad, una cadena de filtros dedicada exclusivamente a la autenticación mediante certificado digital en el endpoint \verb|/login/certificate|. 
    \item En su método \verb|certificateFilterChain|, se crea un extractor de sujeto X.509 (\verb|SubjectDnX509PrincipalExtractor|) que extrae el NIF del DN del certificado mediante una expresión regular, y se instancia un \\\verb|X509AuthenticationFilter| al que se le asigna dicho extractor, un manejador de éxito (\verb|CertificateAuthenticationSuccessHandler|) y se indica que, si la autenticación por certificado falla, continúe la cadena de filtros sin interrumpir la petición. 
    \item Para validar las credenciales preautenticadas del certificado se utiliza un \\\verb|PreAuthenticatedAuthenticationProvider| conectado a un \\\verb|UserDetailsService| personalizado (CertificateUserDetailsService), envolviéndolo en un \verb|ProviderManager| que actúa como \\\verb|AuthenticationManager| del filtro. 
    \item Finalmente, el filtro se añade al \verb|HttpSecurity| limitado únicamente al patrón \verb|/login/certificate|, se establece una política de creación de sesión “si es necesario” y, dado que en entorno de desarrollo he empleado un certificado SSL autogenerado (el cual impide al navegador abrir el selector de certificados bajo protección CSRF), se deshabilita la protección CSRF para este único endpoint, permitiendo así la extracción y validación del certificado sin conflictos, mientras que todas las peticiones quedan autorizadas tras este filtro.
    \item Cabe destacar que en producción no sería necesario desactivar la protección CSRF para ese endpoint puesto que en producción se estaría utilizando un certificado SSL de confianza.

\end{itemize}

\subsection{Servicio de detalles de usuario  }

\begin{itemize}
    \item La clase \verb|UserDetailsService | se encarga de buscar en la base de datos un usuario cuyo NIF/NIE coincida con el extraído del certificado digital correspondiente. En el caso de que dicho usuario exista, crea un \verb|UserDetails| con rol \verb|ROLE_USER|; en caso contrario, se lanza la excepción \\\verb|UsernameNotFoundException|.
    \item El \verb|UserDetails| es necesario para que \verb|Spring Security| pueda completar el paso de pre-autenticación X.509 y poblar el principal de la sesión de seguridad.
\end{itemize}

\subsection{Manejador de éxito de autenticación  }

La clase \verb|config/CertificateAuthenticationSuccessHandler| se encarga de obtener el NIF/NIE extraído y de consultar el repositorio de usuarios. Si no hay coincidencias, redirige a \verb|/login?error=usuario_no_encontrado|. Si hay coincidencia, entonces se termina de autenticar al usuario y se completa de forma exitosa el proceso de autenticación.

\subsection{Consideraciones de seguridad}

Esta implementación permite: \textbf{máxima confianza}, puesto que la validación a nivel TLS impide el paso de clientes no autorizados; \textbf{Integridad del flujo }, puesto que el filtro X.509 y el handler separan claramente la extracción de identidad, la validación en base de datos y la navegación posterior; \textbf{extensibilidad}, gracias a que en \textbf{Spring Security} es sencillo añadir nuevos roles, reglas de autorización o múltiples esquemas de autenticación.

\newpage

\section{Firma y cofirma de los documentos PDF}

\subsection{Generación del PDF a partir de iText}
La clase \verb|service/autofirma/GenerarPdf.java| se encarga de generar el PDF que debe ser firmado o cofirmado a partir de los datos recopilados de un formulario. Los datos del formularios son recogidos y se crea un PDF con un formato acorde y atractivo y en el que incluye toda la información relevante en materia de protección de datos, aludiendo en todo momento tanto a la \textbf{LOPDGDD } y al \textbf{RGPD}.

\subsection{autoscript.js}
El fichero \verb|autoscript.js| representa la “biblioteca de despliegue” del Cliente @firma: al cargarlo dentro del \verb|<head>| de un HTML, se logra aportar un objeto global AutoScript que expone toda la API JavaScript necesaria para invocar todas operaciones de firma disponibles(firma simple, cofirma, contrafirma, firma de lotes, selección de certificado, etc.), encapsulando de este modo los detalles de comunicación con la aplicación nativa.

\subsection{signer-invoke.js}
El fichero \verb|signer-invoke.js| orquesta de manera genérica el flujo de firma y co-firma de documentos en la interfaz web. 

Al pulsar sobre el botón correspondiente a “Firmar”, se recogen los datos del formulario, se llama al método de controlador correspondiente para que se devuelva un PDF en Base64 y se invoca a \verb|AutoScript.sign(...)| para que se abra AutoFirma (o su versión para móvil), se abra el selector de certificados y el usuario pueda firmar el fichero correspondiente. 

Tras recibir la firma en Base64, se envía de nuevo al servidor el documento firmado: Por una parte, en la base de datos se almacenan los siguientes metadatos asociados al documento: nombre, uuid (aleatorio), s3Key (aws), el tipo dearchivo, el tamaño y la fecha de creación.
Por otra parte, el documento completo se sube a aws a partir de la S3 key correspondiente. Se utiliza el uuid para nombrar al documento dentro del bucket para así evitar que se revele metainforación asociada al nombre real del documento.  

Una vez que se ha almacenado los metadatos del fichero y se ha subido a aws, se le muestra al usuario un enlace para poder descargar el PDF recién firmado. Dicho enlace contiene una URL prefirmada para acceder de forma privada al contenido del bucket (todo lo asociado a AWS se explica más adelante con más detalle).

El proceso de cofirma es análogo al proceso ya descito de firma normal. Lo único que cambia es la llamada al fichero AutoScript.js, que ahora pasa a ser \\\verb|AutoScript.cosign(...)|  (se cambia la función \textbf{sign(...)} por \textbf{cosign(...)}).

Este flujo descrito de \textbf{AutoFirma} se repite de forma análoga para las siguientes funcionalidades:

\begin{itemize}
    \item Firma de la autorización de acceso por parte del profesional médico.
    \item Cofirma de la autorización de acceso por parte del paciente.
    \item     Firma de un nuevo informe subido por un profesional médico.
    \item Firma de un nuevo informe editado por un profesional médico
\end{itemize}
Cabe destacar que cualquiera de estas acciones puede ser realizada tanto con \textbf{AutoFirma} como con \textbf{Cliente móvil @firma }.

Por último, cabe destacar que cada vez que se inicia AutoFirma (o su versión para móvil) en el navegador del usuario, en ese preciso instante se muestra un \textbf{overlay} el cual simula una pantalla de carga con el mensaje \textbf{Procesando, por favor espere...}. Este \textbf{overlay} desaparece cuando se ha completado el proceso de firma/cofirma. Gracias a este overlay, se le indica de forma clara al usuario que la aplicación queda en espera durante un corto periodo de tiempo.

De igual modo, cuando el paciente cofirma, recupera del servidor el PDF ya firmado, invoca \verb|AutoScript.cosign(...)| para añadir su firma, y sube el resultado para su descarga. 

\newpage

\subsection{\textbf{Cliente móvil @firma } }


Para conseguir que las funcionalidades de firma y cofirma sigan funcionando en dispositivos móviles, ha sido necesario realizar una serie de cambios \textbf{importantes} y \textbf{no triviales}.

En primer lugar, se ha sustituido el canal de comunicación por sockets (el modo por defecto de AutoFirma) por el mecanismo de "servidor intermedio".

Como se explica en el \textbf{Manual Integrador de AutoFirma}, en un ordenador el JavaScript \textit{autoscript.js} puede abrir un \textit{socket} local  y comunicarse directamente con la aplicación nativa \textbf{AutoFirma} que está escuchando en ese puerto. Este canal bidireccional es rápido y no atraviesa la red, por lo que en en un ordenador resulta la opción más conveniente. 

No obstante, en dispositivos móviles, esta técnica deja de funcionar debido a dos motivos principales:

\begin{itemize}
    \item \textbf{Restricciones de los navegadores y del propio sistema operativo:} Ni Android ni iOS permiten que una página web abra un puerto de escucha local ni que una app nativa exponga un \textit{socket} accesible desde el navegador. El único puente soportado es lanzar la app nativa mediante un esquema de URL (\verb|afirma://…|) y, después, volver al navegador a través de una navegación HTTP/S. 
    \item \textbf{Carencia de la JVM y de la librería de sockets en las versiones móviles del cliente :} Los clientes móviles de @firma no incluyen un servicio que permanezca escuchando; se abren “puntualmente” cuando el navegador invoca el esquema \textit{afirma://}. 
\end{itemize}

Por todo esto, cuando el usuario firma desde \textbf{Android} o \textbf{iOS}, el flujo debe cambiar al mecanismo llamado “\textbf{servidor intermedio}”: 


\begin{itemize}
    \item El JavaScript envía los datos a firmar al \textbf{StorageService} del servidor.
    \item La app móvil recupera esos datos, genera la firma y sube el resultado al mismo servidor.
    \item Finalmente, la página web los recoge a través del \textbf{RetrieveService}.
\end{itemize}


El propio \textbf{manual integrador} lo resume de esta manera en la \textbf{sección 5.3.1}:

“\textit{Los servicios de almacenamiento y recuperación en servidor son necesarios … Cuando el usuario utilice un dispositivo móvil y los clientes móviles Android o iOS}.” 


Habiendo explicado todo lo anterior, para conseguir establecer el mecanismo de \textbf{servidor intermedio} para las operaciones de firma cuando se esté empleando un dispositivo móvil, hay que realizar los siguientes cambios:

\begin{itemize}
    \item Se agrega en \textit{signer-invoke.js} el siguiente fragmento de código encargado de forzar a utilizar el modo de \textbf{servidor intermedio} cuando se está utilizando un dispositivo móvil. Además, este fragmento de código también se encarga de configurar las URLs de los servicios necesarios: \textbf{StorageService} para almacenar los datos que se van a firmar y \textbf{RetrieveService } para recuperar los datos una vez firmados.
\end{itemize}


\begin{figure}[H]
\centering
\noindent\makebox[\textwidth]{\includegraphics[width=0.625\paperwidth]{img/autofirma-movil.jpg}}
\caption{Se fuerza el uso del modo "servidor intermedio" para móviles} \label{fig:autofirma-movil}
\end{figure}

\begin{itemize}
    \item Se despliega un Tomcat externo protegido con TLS el cual se encarga de desplegar los \textbf{WAR} \textit{afirma-signature-storage.war } y \textit{afirma-signature-retriever.war } que implementan los servlets \textit{StorageService} y \textit{RetrieveService} responsables de almacenar y devolver temporalmente los datos firmado.
    \item Para garantizar que las peticiones se cursen siempre dentro del mismo dominio de la aplicación \textbf{VitalSanity} –condición necesaria para evitar bloqueos de tipo XSS/CORS– se ha colocado por delante un \textit{\textbf{Nginx}} para actuar como un \textit{\textbf{proxy inverso}} que expone el puerto 443 y redirige selectivamente las rutas \textit{/vital-sanity/afirma-signature-storage/}, \textit{/…-retriever/} y \textit{/…-triphase-signer/} hacia \textbf{Tomcat}, reenviando el resto del tráfico de la aplicación Spring Boot al puerto 8058; 
    \item Este \textit{\textbf{reverse proxy}} unifica URL y política de seguridad, y añade la directiva CSP que permite el esquema \textbf{\textit{afirma://*}}, requisito necesario de los \textbf{navegadores móviles }.
\end{itemize}

Con todo esto, se consigue que en la aplicación se pueda firmar y cofirmar documentos tanto desde un ordenador (utilizando \textbf{AutoFirma}) como desde un dispositivo móvil (utilizando \textbf{\textbf{Cliente móvil @firma }}).


\section{Configuración de AWS}

\subsection{Dependencias agregadas}

Se ha agregado en el \textbf{POM} la dependencia \textit{software.amazon.awssdk:s3 } la cual habilita todo el sistema de gestión de archivos en la nube mediante Amazon S3. 

\begin{figure}[H]
\centering
\noindent\makebox[\textwidth]{\includegraphics[width=0.625\paperwidth]{img/aws-dependencia-pom.jpg}}
\caption{Dependencia de AWS para Spring Boot} \label{fig:aws-dependencia-pom}
\end{figure}

\subsection{Gestión de credenciales AWS }

Para gestionar las credenciales de AWS de forma segura, se ha ejecutado el comando \textbf{aws configure} (la aplicación se ha desarrollado en Windows). Este comando crea un directorio oculto \textbf{.aws} en el perfil de usuario con dos archivos principales:

\begin{itemize}
    \item \textbf{credentials}: almacena el par \textbf{Access Key ID} y \textbf{Secret Access Key}.
    \item \textbf{config}: define la región por defecto (region = \textbf{eu-south-2}) y formato de salida.
\end{itemize}

Gracias a esto, no se incrustan las credenciales en el código fuente ni en los ficheros de configuración de la aplicación, reduciendo el riesgo de exposición. 


En el código, el SDK de AWS emplea el proveedor por defecto (\textit{DefaultCredentialsProvider}), que busca automáticamente las credenciales en este archivo oculto, o en variables de entorno.

\begin{figure}[H]
\centering
\noindent\makebox[\textwidth]{\includegraphics[width=0.625\paperwidth]{img/aws-default-credential-providers.jpg}}
\caption{Proveedor de credenciales en el código} \label{fig:aws-default-credential-providers}
\end{figure}

\begin{figure}[H]
\centering
\noindent\makebox[\textwidth]{\includegraphics[width=0.65\paperwidth]{img/vv.png}}
\caption{Proveedor de credenciales en el código} \label{fig:vv}
\end{figure}

Cabe destacar que, como VitalSanity es una aplicación dentro del ámbito nacional español, se ha cambiado manualmente la región por defecto del bucket de AWS de forma que ahora la región correspondiente sea \textbf{eu-south-2} (Madrid, España). 

Este cambio de la región por defecto es beneficioso porque garantiza que los datos personales almacenados permanezcan físicamente dentro del territorio español, facilitando así el cumplimiento del \textbf{RGPD} y de la \textbf{LOPDGDD}  al evitar transferencias internacionales de datos que exigirían requisitos legales adicionales. Además, mejora la latencia para usuarios nacionales y refuerza la confianza en la gestión segura de información sensible. 

\subsection{Subida de archivos}

Se utilizan dos métodos principales de la clase \textit{S3VitalSanityService} para la subida de archivos: uno sube un archivo de tipo \textbf{MultipartFile } y otro que sube un archivo de tipo \textit{byte[]}.

\begin{figure}[H]
\centering
\noindent\makebox[\textwidth]{\includegraphics[width=0.625\paperwidth]{img/aws-subirFicheroo-multipaart.jpg}}
\caption{Subir fichero de tipo MultipartFile} \label{aws-subirFicheroo-multipaart:vv}
\end{figure}

\begin{figure}[H]
\centering
\noindent\makebox[\textwidth]{\includegraphics[width=0.625\paperwidth]{img/aws-subirFichero-Bytes.jpg}}
\caption{Subir fichero de tipo byte[]} \label{aws-subirFichero-Bytes.jpg:vv}
\end{figure}

Los ficheros en el bucket no se almacenan con su nombre real, sino que se almacenan con un UUID aleatorio para así ocultar cualquier posible metainformación existente en el nombre real que pudiese revlar cualquier información (aunque sea mínima) a un atacante.

 Se especifica \textit{ServerSideEncryption.AWS-KMS}, delegando la gestión de claves al bucket (SSE-KMS) mediante una clave \textbf{CMK} personalizada (esto se explica más adelante con más detalle)

 \subsection{Generación de URLs pre-firmadas}

 Cada vez que se trata de descargar cualquier docuemtno subido al bucket de aws, se genera una URL prefirmada. Esto permite descargar objetos de S3 sin exponer públicamente el bucket ni requerir credenciales \textbf{AWS}. De esta manera, la URL pública de cualquier objeto dentro del bucket permanece privada, de forma que incluso si un atacante lograse acceso a una de estas URLs y la copiase en el navegador, aún así no podría descargar el documento asociado ya que estaría protegido. Únicamente se puede acceder a los objetos del bucket  a partir de las \textbf{URLs prefirmadas}.


\begin{figure}[H]
\centering
\noindent\makebox[\textwidth]{\includegraphics[width=0.625\paperwidth]{img/aws-url-prefirmadas.jpg}}
\caption{Método para generar una URL prefirmadas} \label{aws-url-prefirmadas:vv}
\end{figure}

\begin{figure}[H]
\centering
\noindent\makebox[\textwidth]{\includegraphics[width=0.625\paperwidth]{img/ejemplo-bucket-inaccesible.jpg}}
\caption{Error cuando se trata de acceder directamente a la URL pública de un documento dentro del bucket de aws} \label{ejemplo-bucket-inaccesible:vv}
\end{figure}

\newpage

Por otra parte, este otro método se utiliza para obtener los bytes de un fichero a partir de su S3Key. Este método es empelado para recuperar la autorización firmada de aws en forma de array de bytes para que el paciente pueda cofirmar dicha autorización.
 \begin{figure}[H]
\centering
\noindent\makebox[\textwidth]{\includegraphics[width=0.625\paperwidth]{img/obtener-bytes-fichero.jpg}}
\caption{Método usado para obtener los bytes de un fichero a partir de su S3Key} \label{obtener-bytes-fichero:vv}
\end{figure}


\newpage

\subsection{Subida de múltiples ficheros a AWS}



Para la subida de múltiples ficheros en AWS se emplea un método de controlador el cual recibe un array de \textbf{MultipartFile}. Por cada fichero se obtiene su nombre, tipo y tamaño, crea en la base de datos un registro (DocumentoData) asociado al informe; se extrae la clave S3 generada (\textbf{s3Key}) y, mediante los métodos que ya hemos visto del servicio \textbf{s3VitalSanityService}, se sube el archivo al bucket de AWS.

Para que todo esto funcione correctamente, en el HTML se agrega un formulario con \textit{enctype="multipart/form-data"} el cual permite el envío de varios ficheros.
Asimismo, se agrega un atributo \textit{accept} para restringir los tipos de los documentos que se pueden subir a \textbf{pdf, jpg, jpeg y png} .

Este método se utiliza para la subida de documentos asociados a un informe médico.

 \begin{figure}[H]
\centering
\noindent\makebox[\textwidth]{\includegraphics[width=0.625 \paperwidth]{img/aws-subir-multiples-documentos.jpg}}
\caption{Método usado para subir múltiples ficheros a ws} \label{aws-subir-multiples-documentos:vv}
\end{figure}


\chapter{Consideraciones legales}

\textbf{
\section{Cumplimiento de protección de datos}
}

La aplicación \textbf{VitalSanity} debe ajustarse estrictamente a la normativa de protección de datos, en especial al RGPD (Reglamento UE 2016/679) y a la LOPDGDD (Ley Orgánica 3/2018). Los datos de salud se consideran categorías especiales de datos que requieren protección reforzada, por lo que su tratamiento solo es lícito si se cuenta con una base jurídica adecuada y garantías elevadas de seguridad. 

En este sentido, se debe respetar el derecho a la \textbf{confidencialidad} de la información médica de cada paciente: la Ley de Autonomía del Paciente (Ley 41/2002) establece que nadie puede acceder a datos sanitarios sin la debida legitimación o autorización previa del afectado. VitalSanity debe aplicar el principio de \textit{privacidad desde el diseño}, implementando medidas técnicas y organizativas robustas (control de accesos, cifrado, seudonimización, etc.) para asegurar la \textbf{integridad} y \textbf{confidencialidad} de la información. 

Igualmente, se tiene que facilitar que los pacientes ejerzan sus derechos ARSOP (acceso, rectificación, supresión, oposición, limitación del tratamiento y portabilidad) sobre sus datos personales. En concordancia con el principio de responsabilidad proactiva del RGPD, será necesario llevar un registro de actividades de tratamiento, realizar evaluaciones de riesgo y notificar a la autoridad de protección de datos cualquier brecha de seguridad relevante. 

Por último, si la escala o naturaleza del tratamiento lo requiere (p. ej., tratamiento masivo de datos de salud), se deberá designar un \textbf{Delegado de Protección de Datos (DPO)} para supervisar el cumplimiento normativo.

 \textbf{Posibilidad de revocación: }Asimismo, destacar que el consentimiento informado \textbf{no es irrevocable}; el paciente tiene derecho a retirarlo en cualquier momento. En consecuencia, \textit{VitalSanity} debe habilitar la revocación ágil de permisos previamente concedidos. Si un paciente decide denegar acceso a cierto profesional, la aplicación debe hacer efectiva esa revocación inmediatamente, notificando al sistema para que el profesional ya no pueda consultar la historia clínica. Este mecanismo de revocación es parte integral del respeto a la autonomía del paciente y debe ser tan sencillo como lo fue otorgar el permiso.

\section{  \textbf{Consentimiento informado del paciente}
}

Todo acceso o uso de información clínica a través de VitalSanity debe estar amparado por el \textbf{consentimiento informado} del paciente. La Ley 41/2002 reconoce el derecho del paciente a ser plenamente informado de cualquier actuación médica y a decidir libremente sobre la misma, exigiendo que su aceptación conste por escrito mediante un consentimiento expreso.

En línea con este mandato, VitalSanity debe asegurarse de obtener un consentimiento específico, libre e informado del paciente antes de acceder a su historial clínico o compartir sus datos, una vez que el paciente haya sido adecuadamente informado sobre las finalidades y el alcance de dicho acceso. 

Este consentimiento puede materializarse de forma digital: la aplicación debería integrar mecanismos de firma electrónica para que el paciente firme los documentos de consentimiento de manera \textbf{segura y legalmente válida}. En particular, el uso de la herramienta oficial \textbf{AutoFirma} (y su cliente móvil @firma) permitiría recabar la firma electrónica avanzada o cualificada del paciente, de conformidad con el Reglamento eIDAS, otorgándole a ese consentimiento digital la misma validez jurídica que tendría en papel.

De esta forma, se garantiza la autenticidad del consentimiento y se respeta plenamente la autonomía del paciente, dado que ningún profesional ajeno a su atención podrá acceder a sus datos de salud sin la debida autorización del propio paciente.

\textbf{
\section{Historia clínica (gestión, acceso y custodia)}
}

VitalSanity debe gestionar la \textbf{historia clínica digital} de cada paciente cumpliendo con los requisitos legales en materia de documentación sanitaria. La historia clínica es el conjunto de documentos e información relativa a la salud de un paciente, y tiene carácter \textbf{confidencial}. Solo el personal sanitario directamente implicado en la asistencia tiene permiso para acceder a ella, tal como señala la Ley 41/2002.

En consecuencia, la aplicación debe garantizar que únicamente los profesionales autorizados puedan consultar o modificar el historial clínico, implementando controles de acceso estrictos y registrando toda actividad (accesos, incorporaciones de datos, etc.) para mantener trazabilidad y detectar accesos indebidos. 

Además, VitalSanity debe preservar la \textbf{integridad} y \textbf{autenticidad} de la información clínica: cualquier dato incorporado al historial debe permanecer completo, fidedigno y asociado al profesional que lo aportó, igual que ocurriría en un expediente médico tradicional.

Por otro lado, la \textbf{custodia} legal de la historia clínica recae en el proveedor sanitario (hospital, clínica o profesional) que genera la documentación. VitalSanity, como herramienta, debe facilitar el cumplimiento de dichas obligaciones de custodia sin suplantarlas. 

Los centros sanitarios tienen el deber de archivar y conservar la documentación clínica en condiciones adecuadas de seguridad, al menos durante \textbf{cinco años} desde la fecha de alta de cada proceso asistencial (o plazos mayores según normativas autonómicas o del tipo de documento). La aplicación deberá apoyar esta conservación segura de los datos en formato electrónico, garantizando su disponibilidad cuando se requiera para la asistencia y su protección frente a pérdidas o alteraciones. 

Asimismo, debe respetarse el criterio de \textbf{unidad de la historia clínica}: cada paciente ha de tener un registro unificado por centro sanitario, que incorpore todos sus episodios asistenciales relevantes. VitalSanity debe por tanto integrarse con los sistemas de información sanitarios existentes para evitar la fragmentación de la información, asegurando que el historial clínico digital que maneja sea completo y esté sincronizado con la historia oficial del centro. 

Finalmente, se debe recordar que el paciente tiene derecho a acceder a la información de su propia historia clínica (salvo excepciones legales puntuales); la aplicación podría facilitar este derecho, por ejemplo, mediante módulos de portal del paciente, siempre cumpliendo con las garantías de seguridad y confidencialidad previstas.

\section{\textbf{Interoperabilidad entre sistemas sanitarios}}

La legislación sanitaria española promueve la \textbf{interoperabilidad} de los sistemas clínicos, con el fin de garantizar la continuidad asistencial del paciente a través de distintos niveles y centros de atención. La propia Ley 41/2002, en una disposición adicional, instó a desarrollar sistemas compatibles que permitieran el uso compartido de la historia clínica del paciente entre distintos establecimientos sanitarios, evitando duplicidades diagnósticas o pruebas innecesarias. 

Más adelante, la Ley 16/2003 de Cohesión y Calidad del SNS, en su artículo 56, encomendó al Ministerio de Sanidad coordinar con las Comunidades Autónomas los mecanismos de intercambio electrónico de información de salud, de forma que tanto los profesionales sanitarios que atienden al paciente como el propio paciente puedan acceder a los datos clínicos precisos para su asistencia, garantizando en todo caso la confidencialidad e integridad de la información.

En aplicación de este marco, se aprobó el \textbf{Real Decreto 1093/2010}, que establece el conjunto mínimo de datos comunes que deben contener ciertos informes clínicos (informes de alta, historias resumidas, etc.) en todo el Sistema Nacional de Salud.

Dicho estándar unifica el formato básico de la información para facilitar su intercambio entre los distintos servicios de salud autonómicos. 

En este contexto, VitalSanity debe ser capaz de integrarse e \textbf{interoperar} con otros sistemas sanitarios, tanto públicos como privados. Por un lado, la aplicación ha de adoptar los estándares nacionales mencionados (estructuras de datos, terminologías clínicas, formatos de intercambio como HL7/FHIR, etc.) para comunicarse eficazmente con la historia clínica digital de los servicios de salud. 

De esta forma, VitalSanity debe de cumplir con el hecho de que en España \textbf{no existen impedimentos legales} para el intercambio de información clínica entre el sector público y el privado. Para ello siempre debe de mediar el consentimiento previo del paciente. 

Esto implica que VitalSanity puede, con la autorización explícita del paciente, acceder a datos provenientes de diferentes fuentes (por ejemplo, historiales de un hospital público y de una clínica privada) y presentarlos de forma unificada al profesional o al propio paciente. La aplicación debe, por tanto, estar preparada para \textbf{respetar los protocolos de interoperabilidad} vigentes (p. ej. servicios web del Nodo de Intercambio del SNS) y a la vez \textbf{garantizar la seguridad} en esas transferencias de datos (cifrado de las comunicaciones, autenticación de los sistemas que intercambian información, etc.), de acuerdo con las exigencias legales y de las políticas de cada institución involucrada.




{
\section{Esquema Nacional de Seguridad (ENS):}
} 
Dada la naturaleza sensible de los datos de salud, es obligatorio aplicar medidas de seguridad de nivel elevado según el ENS cuando la aplicación se integra en el sector público o maneja información de pacientes de servicios públicos. El ENS, establecido por el RD 3/2010 (actualizado por RD 311/2022), proporciona un marco de buenas prácticas de seguridad orientado a proteger la información en las administraciones públicas y sus sistemas asociados\href{https://quodem.com/blog/el-papel-del-ens-en-el-sector-de-la-salud/\#:~:text=Con\%20el\%20objetivo\%20de\%20garantizar,la\%20correcta\%20gesti\%C3\%B3n\%20de\%20estos}{quodem.com}. VitalSanity debe alinearse con estas exigencias, implementando controles como autenticación robusta (ej. \textbf{autenticación con certificado digital}), gestión estricta de permisos de usuario, cifrado de las comunicaciones, registro y monitorización de accesos, planes de respuesta ante incidentes, copias de seguridad, entre otras medidas. Cumplir con el ENS garantiza un nivel de protección acorde al exigido en el ámbito sanitario público y refuerza la confianza en la aplicación.

\section{Reglamento eIDAS y firma electrónica}
 El Reglamento (UE) n.º 910/2014 \textbf{eIDAS} sobre identificación electrónica y servicios de confianza, junto con la Ley 59/2003 española de firma electrónica, establecen las condiciones bajo las cuales una \textbf{firma electrónica avanzada o cualificada} tiene el mismo valor legal que la firma manuscrita en documentos oficiales. En el contexto de VitalSanity, esto implica que los consentimientos informados y demás documentos clínicos firmados digitalmente a través de la aplicación (por ejemplo, utilizando certificados digitales reconocidos mediante AutoFirma) gozarán de plena validez jurídica. La plataforma debe, por tanto, utilizar certificados y métodos de firma electrónica que cumplan estos estándares, garantizando la \textbf{autenticidad}, \textbf{integridad} y el \textbf{no repudio} de los documentos firmados. De esta forma, tanto pacientes como profesionales pueden firmar electrónicamente consentimientos, informes o autorizaciones con la certeza de que dichos actos tienen eficacia legal y probatoria equivalente a los tradicionales en papel.
 
 
\section{Consideraciones éticas}
 Más allá del cumplimiento legal, la gestión de datos de salud conlleva importantes responsabilidades éticas. VitalSanity debe adherirse a los \textbf{principios éticos} que rigen la relación sanitario-paciente y el uso de información sensible. Esto incluye el respeto estricto del \textbf{secreto profesional} y la privacidad del paciente: toda persona que acceda a datos mediante la aplicación debe estar sujeta a deberes de confidencialidad profesionales. Igualmente, el principio de \textbf{autonomía del paciente} exige que las decisiones sobre el uso de sus datos estén centradas en su consentimiento y preferencias, evitando cualquier forma de coerción o uso indebido de la información. La \textbf{beneficencia} y la \textbf{no maleficencia} han de guiar el diseño de la herramienta: sus funcionalidades (por ejemplo, algoritmos de ayuda a la decisión clínica) deben buscar mejorar la calidad de la atención sin causar perjuicios ni discriminar pacientes. Es aconsejable que VitalSanity se desarrolle bajo un enfoque de \textit{ética de datos}, asegurando transparencia en cómo se usan los datos, minimizando la recopilación a lo necesario y garantizando un uso justo y responsable de la información (por ejemplo, si se utilizan datos anónimos para investigación, hacerlo con las debidas autorizaciones de comité ético). 

  






\appendix
\chapter{Bibliografía}\label{enlaces}

Destacar que para la realización de este trabajo se ha empleado únicamente como referencia el material proporcionado  en la asignatura de Gestion de Calidad Software, así como el uso de la IA ya mencionado. 

A continuación, se adjuntan los enlaces de descarga de las aplicaciones mencionadas en el apartado de 'Análisis de competencia':

\begin{itemize}

\item Descarga de la aplicación 'Flush - Public Toliet Finder': \url{https://play.google.com/store/apps/details?id=toilet.samruston.com.toilet}

\item Descarga de la aplicación 'OstomiAseo': \url{https://play.google.com/store/apps/details?id=com.viacoreit.ostomiaseo}

\item Descarga de la aplicación 'Toilet Finder': \url{https://play.google.com/store/apps/details?id=com.bto.toilet}

\end{itemize}

\end{document}
